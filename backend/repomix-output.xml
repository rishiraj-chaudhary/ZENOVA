This file is a merged representation of the entire codebase, combined into a single document by Repomix.

<file_summary>
This section contains a summary of this file.

<purpose>
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.
</purpose>

<file_format>
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Repository files (if enabled)
5. Multiple file entries, each consisting of:
  - File path as an attribute
  - Full contents of the file
</file_format>

<usage_guidelines>
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.
</usage_guidelines>

<notes>
- Some files may have been excluded based on .gitignore rules and Repomix's configuration
- Binary files are not included in this packed representation. Please refer to the Repository Structure section for a complete list of file paths, including binary files
- Files matching patterns in .gitignore are excluded
- Files matching default ignore patterns are excluded
- Files are sorted by Git change count (files with more changes are at the bottom)
</notes>

</file_summary>

<directory_structure>
config/
  database.js
  gamification.js
controllers/
  authController.js
  gamificationController.js
  geminiController.js
  leaderboardController.js
  moodController.js
  musicController.js
  playlistController.js
  userController.js
middlewares/
  authMiddleware.js
  errorHandler.js
  gamificationMiddleware.js
  sessionMiddleware.js
models/
  Badge.js
  Challenge.js
  Gamification.js
  Leaderboard.js
  MusicResource.js
  Playlist.js
  Recommendation.js
  TherapySession.js
  user.js
routes/
  authRoutes.js
  gamificationRoutes.js
  geminiRoutes.js
  leaderboardRoutes.js
  moodRoutes.js
  musicRoutes.js
  playlistRoutes.js
  userRoutes.js
services/
  badgeService.js
  leaderboardService.js
  pointsService.js
  socketManager.js
utils/
  passwordUtils.js
package-lock 2.json
package.json
server.js
</directory_structure>

<files>
This section contains the contents of the repository's files.

<file path="config/database.js">
import dotenv from "dotenv";
import mongoose from "mongoose";

dotenv.config();

const connectDB = async () => {
  try {
    const mongoURI = process.env.MONGO_URI || 'mongodb://127.0.0.1:27017/therapy';
    await mongoose.connect(mongoURI);
    console.log("MongoDB Connected");
    
  } catch (error) {
    console.error("MongoDB Connection Error:", error);
    process.exit(1);
  }
};

export default connectDB;
</file>

<file path="config/gamification.js">
export const POINTS = {
  PLAYLIST_CREATED: 10,
  SONG_ADDED: 5,
  PLAYLIST_SHARED: 15,
  DAILY_LOGIN: 5,
  STREAK_BONUS: 10, // per day of streak
  THERAPY_SESSION_COMPLETED: 25
};

export const LEVELS = [
  { level: 1, name: 'Beginner', minPoints: 0 },
  { level: 2, name: 'Explorer', minPoints: 40 },
  { level: 3, name: 'Curator', minPoints: 500 },
  { level: 4, name: 'Therapist', minPoints: 1500 },
  { level: 5, name: 'Master', minPoints: 5000 }
];
export const BADGES = [
  {
    name: 'First Steps',
    description: 'Created your first playlist',
    requirement: { type: 'playlist_count', value: 1 },
    category: 'creation',
    rarity: 'common',
    icon: 'fa-solid fa-star-of-david'
  },
  {
    name: 'Playlist Pro',
    description: 'Created 10 playlists',
    requirement: { type: 'playlist_count', value: 10 },
    category: 'creation',
    rarity: 'epic',
    icon: 'fa-solid fa-meteor' // ‚òÑÔ∏è
  },
  {
    name: 'Week Warrior',
    description: '7-day streak',
    requirement: { type: 'streak_days', value: 7 },
    category: 'streak',
    rarity: 'legendary',
    icon: 'fa-brands fa-old-republic' // üõ°Ô∏è
  },
  {
    name: 'Month Master',
    description: '30-day streak',
    requirement: { type: 'streak_days', value: 30 },
    category: 'streak',
    rarity: 'rare',
    icon: 'fa-brands fa-jedi-order' // üßò
  }
];
</file>

<file path="controllers/authController.js">
import { validationResult } from 'express-validator'; //validate request body
import jwt from 'jsonwebtoken';
import mongoose from 'mongoose';
import User from '../models/user.js';
import { hashPassword, matchPassword } from '../utils/passwordUtils.js';

//generate a jwt token for the current user
const generateToken = (id) => {
    return jwt.sign({ id, timestamp: Date.now() }, process.env.JWT_SECRET, {
      expiresIn: '30d',
    });
  };

//register user route
export const register = async (req, res) => {
    const { name, email, password } = req.body;
    //valid request body
    const error = validationResult(req);
    if (!error.isEmpty()) {
        return res.status(400).json({ error: error.array() });
    }
    try {
        let existingUser = await User.findOne({ email });
        if (existingUser) {
            return res.status(400).json({ message: 'User already exists' });
        }
        const hashPass = await hashPassword(password);
        const newUser = new User({
            _id: new mongoose.Types.ObjectId(),
            name,
            email,
            password: hashPass
        });
        await newUser.save();


        const token =  generateToken(newUser._id);
        return res.status(201).json({
            message: 'user registered successfully',
            token,
            user: {
                _id: newUser._id,
                name: newUser.name,
                email: newUser.email
            }
        });
    } catch (err) {
        console.error('Registration error:', err);
        return res.status(500).json({ message: 'Server error', error: err.message });
    }
}

//login user route
export const login = async (req, res,next) => {
    try {
        const { email, password } = req.body;
        const existingUser = await User.findOne({ email });
        
        if (!existingUser) {
            return res.status(400).json({ message: 'Invalid credentials' });
        }
        
        // Check password
        const isMatch = await matchPassword(password, existingUser.password);
        if (!isMatch) {
            return res.status(400).json({ message: 'Invalid credentials' });
        }
        
        // Save existingUser info in session
        req.session.user = {
            _id: existingUser._id,
            name: existingUser.name,
            email: existingUser.email
        };
        const token=generateToken(existingUser._id);
        // Send existingUser data back without password
        const userData = {
            token ,
            _id: existingUser._id,
            name: existingUser.name,
            email: existingUser.email
        };
        
        req.user=existingUser;
        res.status(200).json({ user: userData });
        next();
    } catch (err) {
        console.error(err);
        res.status(500).json({ message: 'Server error' });
    }
};

export const logout = (req, res) => {
    req.session.destroy(err => {
        if (err) {
            return res.status(500).json({ message: 'Failed to logout' });
        }
        res.clearCookie('connect.sid');
        res.status(200).json({ message: 'Logged out successfully' });
    });
};

export const checkAuth = (req, res) => {
    if (req.session.user) {
        res.status(200).json({ user: req.session.user });
    } else {
        res.status(401).json({ message: 'Not authenticated' });
    }
};
</file>

<file path="controllers/gamificationController.js">
import { UserBadge } from '../models/Badge.js';
import Gamification from '../models/Gamification.js';
import { checkAndAwardBadges } from '../services/badgeService.js';
import { awardPoints } from '../services/pointsService.js';

export const getUserStats=async(req,res)=>{
    try{
        const {userId}=req.params;
        const gamification=await Gamification.findOne({userId});
        const badges=await UserBadge.find({userId}).populate('badgeId');
        res.json({
            points: gamification?.totalPoints || 0,
            level: gamification?.level || 1,
            streak: gamification?.currentStreak || 0,
            playlistsShared: gamification?.playlistsShared || 0,
            dailyLogins: gamification?.dailyLogins || 0,
            badges: badges.map(ub => ub.badgeId)
        });
    }catch(err){
        res.status(500).json({ error: err.message }); 
    }
}

export const awardPointsController = async(req,res)=>{
    try{
        const {userId,action}=req.body;
        const socketManager=req.socketManager;
        const result=await awardPoints(userId,action,socketManager);
        await checkAndAwardBadges(userId,socketManager);
        res.json(result);
    }catch(err){
        res.status(500).json({ error: err.message });
    }
}
</file>

<file path="controllers/geminiController.js">
import { GoogleGenerativeAI } from "@google/generative-ai";
import dotenv from "dotenv";
import mongoose from "mongoose";

dotenv.config();

// Initialize Gemini AI
const genAI = new GoogleGenerativeAI(process.env.GEMINI_API_KEY);

export const analyzeMood = async (req, res) => {
    try {
        const { userId, userInput } = req.body;

        console.log("Received request with:", { userId, userInput });

        // Validate userId format
        if (!userId || typeof userId !== 'string' || (userId !== "guest" && (userId.length !== 24 || !/^[0-9a-fA-F]{24}$/.test(userId)))) {
            console.error("Invalid userId Detected:", userId);
            return res.status(400).json({ 
                message: "Invalid userId format", 
                details: "Must be a 24-character hex string or 'guest'",
                receivedUserId: userId
            });
        }

        let objectId = null;
        if (userId !== "guest") {
            try {
                objectId = new mongoose.Types.ObjectId(userId);
                console.log('‚úÖ Converted ObjectId:', objectId);
            } catch (idError) {
                console.error('‚ùå ObjectId Conversion Error:', idError);
                return res.status(400).json({ 
                    message: "Invalid userId format", 
                    details: idError.message 
                });
            }
        }


        // üß† Use Gemini API to Analyze Mood
        const model = genAI.getGenerativeModel({ model: "gemini-2.0-flash" });

        const prompt = `Analyze the mood from the following user input and provide a one-word mood description: "${userInput}"`;

        const result = await model.generateContent(prompt);
        const response = await result.response;
        const moodResponse = response.text();

        console.log("Gemini Mood Analysis Result:", moodResponse);

        return res.json({
            message: "Mood analyzed successfully",
            mood: moodResponse.trim(),
        });

    } catch (err) {
        console.error("Error in mood analysis:", err);
        res.status(500).json({ message: "Internal server error" });
    }
};
export const chatWithAI = async (req, res) => {
    try {
        const { userId, userInput } = req.body;
        
        if (!userInput) return res.status(400).json({ message: "Input required!" });

        try {
            const model = genAI.getGenerativeModel({ model: "gemini-2.0-flash" });
                         
            const prompt = `You are a music therapy assistant created by RISHIRAJ, an undergrad at NSUT, to help users find and compile music that matches their needs and emotions.

        CORE INSTRUCTIONS:
        1. **About Creator**: If asked who made you, mention RISHIRAJ from NSUT and suggest artists like NF, Eminem, and Billie Eilish as examples of emotionally impactful music.

        2. **Song Recommendations**:
        - Always provide 3-5 specific song suggestions with artist names
        - Match songs to the user's mood, situation, or explicit request
        - Focus on popular/well-known songs unless user specifically asks for "hidden gems", "underrated", "lesser-known", or "indie" music
        - Include a mix of genres when appropriate (pop, hip-hop, rock, indie, etc.)
        - Explain briefly why each song fits their request

        3. **Response Format**:
        - Start with empathetic acknowledgment of their input
        - Provide song recommendations in this format: "Song Title" by Artist Name
        - Add 1-2 sentences about why the song fits
        - End with encouraging words

        4. **Mood Categories to Consider**:
        - Happy/Upbeat: energetic, celebratory songs
        - Sad/Melancholy: emotional, reflective songs 
        - Motivated/Pumped: workout, motivational tracks
        - Relaxed/Chill: calming, ambient music
        - Angry/Frustrated: cathartic, intense songs
        - Nostalgic: throwback, sentimental tracks
        - Focus/Study: instrumental, lo-fi beats

        5. **Special Requests**:
        - If user asks for specific genres, decades, or artists, prioritize those
        - If user mentions activities (workout, study, sleep), tailor accordingly
        - Only suggest lesser-known/indie songs when explicitly requested

        EXAMPLE RESPONSES:
        - For "I'm feeling down": "I understand you're going through a tough time. Here are some songs that might help: 'Breathe Me' by Sia, 'Heavy' by Linkin Park ft. Kiiara, 'Someone You Loved' by Lewis Capaldi..."
        - For "I need workout music": "Let's get you pumped up! Try these high-energy tracks: 'Till I Collapse' by Eminem, 'Stronger' by Kanye West, 'Eye of the Tiger' by Survivor..."

        User input: "${userInput}"`;
                         
            const result = await model.generateContent(prompt);
            console.log('Gemini AI Response:', result.response);
                         
            const aiResponse = result.response.text || result.response.message || result.response.content || "No response";
 
            res.json({
                 response: aiResponse,
                userId: userId || null
            });
        } catch (apiError) {
            console.error("Gemini AI Chat API Error:", apiError);
            res.status(500).json({ message: "AI chat failed.", error: apiError.message });
        }
    } catch (err) {
        console.error("Error in AI chat:", err);
        res.status(500).json({ message: "Chat processing failed." });
    }
};


// import { GoogleGenerativeAI } from "@google/generative-ai";
// import dotenv from "dotenv";
// import mongoose from "mongoose";
// import MusicResource from "../models/MusicResource.js";
// import User from "../models/user.js";

// dotenv.config();

// // Initialize Gemini AI
// const genAI = new GoogleGenerativeAI(process.env.GEMINI_API_KEY);

// export const analyzeMood = async (req, res) => {
//     try {
//         const { userId, userInput } = req.body;
        
//         console.log("Received request with:", { userId, userInput });
        
//         // Validate userId format
//         if (!userId || typeof userId !== 'string' || (userId !== "guest" && (userId.length !== 24 || !/^[0-9a-fA-F]{24}$/.test(userId)))) {
//             console.error("Invalid userId Detected:", userId);
//             return res.status(400).json({
//                 message: "Invalid userId format",
//                 details: "Must be a 24-character hex string or 'guest'",
//                 receivedUserId: userId
//             });
//         }
        
//         let objectId = null;
//         if (userId !== "guest") {
//             try {
//                 objectId = new mongoose.Types.ObjectId(userId);
//                 console.log('‚úÖ Converted ObjectId:', objectId);
//             } catch (idError) {
//                 console.error('‚ùå ObjectId Conversion Error:', idError);
//                 return res.status(400).json({
//                     message: "Invalid userId format",
//                     details: idError.message
//                 });
//             }
//         }
        
//         // üß† Use Gemini API to Analyze Mood
//         const model = genAI.getGenerativeModel({ model: "gemini-2.0-flash" });
        
//         const prompt = `Analyze the mood from the following user input and provide a one-word mood description: "${userInput}"`;
        
//         const result = await model.generateContent(prompt);
//         const response = await result.response;
//         const moodResponse = response.text();
        
//         console.log("Gemini Mood Analysis Result:", moodResponse);
        
//         // Store mood in user profile if not guest
//         if (userId !== "guest") {
//             try {
//                 await User.findByIdAndUpdate(objectId, {
//                     $push: { moodTracking: { mood: moodResponse.trim(), date: new Date() } }
//                 });
//             } catch (dbError) {
//                 console.error("Failed to update user mood tracking:", dbError);
//                 // Continue anyway - non-critical error
//             }
//         }
        
//         // ‚úÖ Send Mood Response
//         return res.json({
//             message: "Mood analyzed successfully",
//             mood: moodResponse.trim(),
//         });
        
//     } catch (err) {
//         console.error("Error in mood analysis:", err);
//         res.status(500).json({ message: "Internal server error" });
//     }
// };

// export const chatWithAI = async (req, res) => {
//     try {
//         const { userId, userInput } = req.body;
        
//         if (!userInput) return res.status(400).json({ message: "Input required!" });
        
//         try {
//             const model = genAI.getGenerativeModel({ model: "gemini-2.0-flash" });
            
//             const prompt = `You are a music therapy assistant.
//             Provide a supportive, empathetic response to the following user input,
//             keeping the tone helpful and constructive:
            
//             User input: "${userInput}"`;
            
//             const result = await model.generateContent(prompt);
//             console.log('Gemini AI Response:', result.response); // Check response structure
            
//             const aiResponse = result.response.text || result.response.message || result.response.content || "No response";
//             console.log("Extracted AI Response:", aiResponse); // Add this for debugging
//             res.json({
//                 response: aiResponse,
//                 mood: detectedMood,
//                 conversationState: nextState,
//                 recommendations: recommendations
//             });
//         } catch (apiError) {
//             console.error("Gemini AI Chat API Error:", apiError);
//             res.status(500).json({ message: "AI chat failed.", error: apiError.message });
//         }
//     } catch (err) {
//         console.error("Error in AI chat:", err);
//         res.status(500).json({ message: "Chat processing failed." });
//     }
// };

// export const chat = async (req, res) => {
//     try {
//         const { userId, userInput, conversationState } = req.body;
        
//         if (!userInput) return res.status(400).json({ message: "Input required!" });
        
//         // Default conversation state if not provided
//         const currentState = conversationState || {
//             stage: 'greeting',
//             contextMood: null,
//             previousResponses: [],
//             userPreferences: {
//                 genre: [],
//                 artists: [],
//                 tempo: null,
//                 purpose: null
//             }
//         };
        
//         try {
//             const model = genAI.getGenerativeModel({ model: "gemini-2.0-flash" });
            
//             // Get user info if available
//             let userInfo = {};
//             if (userId !== "guest" && mongoose.Types.ObjectId.isValid(userId)) {
//                 const user = await User.findById(userId);
//                 if (user) {
//                     userInfo = {
//                         name: user.name || "User",
//                         favoriteGenres: user.preferences?.favoriteGenres || [],
//                         favoriteArtists: user.preferences?.favoriteArtists || [],
//                         moodHistory: user.moodTracking?.slice(-5) || []
//                     };
//                 }
//             }
            
//             // Build conversation history
//             const previousConversation = currentState.previousResponses.map((message, index) => {
//                 return (index % 2 === 0) 
//                     ? `User: ${message}`
//                     : `Assistant: ${message}`;
//             }).join('\n');
            
//             // Build prompt based on conversation stage
//             let prompt = "";
            
//             switch (currentState.stage) {
//                 case 'greeting':
//                     prompt = `You are a music therapy assistant that can have meaningful conversations with users and recommend music based on their mood and preferences.
                    
//                     Your conversation goal is to understand how the user is feeling and help them through music. Ask follow-up questions to understand their emotional state better.
                    
//                     User information:
//                     ${JSON.stringify(userInfo)}
                    
//                     Previous conversation:
//                     ${previousConversation}
                    
//                     User's latest message: "${userInput}"
                    
//                     Analyze if the user expressed any mood in their message. If so, note it. If not, ask them about their current mood in a conversational way.
//                     Ask what kind of music they would like to hear or what they need music for right now (relaxation, energy, focus, etc).
                    
//                     Respond in a friendly, supportive tone with no more than 2-3 short paragraphs.`;
//                     break;
                    
//                 case 'mood_exploration':
//                     prompt = `You are a music therapy assistant that can have meaningful conversations with users and recommend music based on their mood and preferences.
                    
//                     Your conversation goal is to understand the user's current emotional state and preferences in depth.
                    
//                     User information:
//                     ${JSON.stringify(userInfo)}
                    
//                     Previous conversation:
//                     ${previousConversation}
                    
//                     Current understanding of user's mood: ${currentState.contextMood || "Unknown"}
                    
//                     User's latest message: "${userInput}"
                    
//                     Further explore the user's mood or musical preferences. If they've expressed a clear mood, confirm it and ask about their music preferences 
//                     (genre, artist, tempo, etc.) for this mood. If they've shared music preferences, confirm understanding and ask if they're looking for music to 
//                     enhance their current mood or change it.
                    
//                     Respond in a friendly, supportive tone with no more than 2-3 short paragraphs.`;
//                     break;
                    
//                 case 'music_preference':
//                     prompt = `You are a music therapy assistant that can have meaningful conversations with users and recommend music based on their mood and preferences.
                    
//                     Your conversation goal is to finalize music preferences and prepare to make recommendations.
                    
//                     User information:
//                     ${JSON.stringify(userInfo)}
                    
//                     Previous conversation:
//                     ${previousConversation}
                    
//                     Current understanding of user's mood: ${currentState.contextMood || "Unknown"}
//                     Current music preferences: ${JSON.stringify(currentState.userPreferences)}
                    
//                     User's latest message: "${userInput}"
                    
//                     Based on the user's response, finalize your understanding of their musical needs. If they've shared specific preferences (artists, genres, 
//                     tempo, purpose of listening), confirm these. If they're asking for recommendations now, acknowledge that and prepare to provide them. 
//                     If they're asking for something else entirely, address that appropriately.
                    
//                     Respond in a friendly, supportive tone with no more than 2-3 short paragraphs.`;
//                     break;
                    
//                 case 'recommendation':
//                     prompt = `You are a music therapy assistant that can have meaningful conversations with users and recommend music based on their mood and preferences.
                    
//                     Your conversation goal is to discuss music recommendations and gather feedback.
                    
//                     User information:
//                     ${JSON.stringify(userInfo)}
                    
//                     Previous conversation:
//                     ${previousConversation}
                    
//                     Current understanding of user's mood: ${currentState.contextMood || "Unknown"}
//                     Current music preferences: ${JSON.stringify(currentState.userPreferences)}
                    
//                     User's latest message: "${userInput}"
                    
//                     The user has been shown music recommendations. Respond to their feedback or questions about the recommendations. If they seem satisfied, 
//                     ask if they'd like to explore more music or if they have any other needs. If they seem unsatisfied, ask what kind of music would better 
//                     suit their needs right now.
                    
//                     Respond in a friendly, supportive tone with no more than 2-3 short paragraphs.`;
//                     break;
                    
//                 default:
//                     // Default conversation prompt
//                     prompt = `You are a music therapy assistant that can have meaningful conversations with users and recommend music based on their mood and preferences.
                    
//                     Previous conversation:
//                     ${previousConversation}
                    
//                     User's latest message: "${userInput}"
                    
//                     Respond in a helpful, friendly manner. If they're expressing a mood or asking about music, help them explore that. If they're giving feedback
//                     on recommendations, respond appropriately. Always maintain a supportive, therapeutic tone.
                    
//                     Respond in a friendly, supportive tone with no more than 2-3 short paragraphs.`;
//             }
            
//             // Generate AI response
//             const result = await model.generateContent(prompt);
//             const aiResponse = result.response.text();
            
//             // Analyze for mood detection
//             let detectedMood = null;
//             let shouldUpdateMood = false;
//             if (currentState.stage === 'greeting' || currentState.stage === 'mood_exploration') {
//                 // Try to detect mood from user input
//                 const moodAnalysisPrompt = `Based on this user message, identify the primary emotional state or mood expressed. 
//                 Return ONLY a single word representing the mood: "${userInput}"`;
                
//                 const moodResult = await model.generateContent(moodAnalysisPrompt);
//                 const moodResponse = moodResult.response.text().trim();
                
//                 // Only update if we get a valid mood word
//                 if (moodResponse && moodResponse.length < 20) {
//                     detectedMood = moodResponse;
//                     shouldUpdateMood = true;
//                 }
//             }
            
//             // Analyze conversation state
//             const stateAnalysisPrompt = `Analyze the current conversation stage based on this exchange:
            
//             Previous conversation:
//             ${previousConversation}
            
//             User's latest message: "${userInput}"
//             Bot's response: "${aiResponse}"
            
//             Current stage: ${currentState.stage}
            
//             Decide the next conversation stage:
//             - greeting: Initial greeting and mood assessment
//             - mood_exploration: Exploring and understanding mood in more depth
//             - music_preference: Gathering music preferences
//             - recommendation: Ready for or discussing music recommendations
            
//             Also extract any music preferences mentioned by the user (genres, artists, tempo, purpose of listening).
            
//             Return valid JSON in this format:
//             {
//                 "nextStage": "one_of_the_stages_above",
//                 "userPreferences": {
//                     "genre": ["list", "of", "genres"],
//                     "artists": ["list", "of", "artists"],
//                     "tempo": "fast/medium/slow or null",
//                     "purpose": "relaxation/focus/energy/sleep/etc or null"
//                 }
//             }`;
            
//             const stateResult = await model.generateContent(stateAnalysisPrompt);
//             const stateAnalysis = stateResult.response.text();
            
//             // Parse state analysis
//             let nextState = { ...currentState };
//             try {
//                 const stateData = JSON.parse(stateAnalysis);
//                 if (stateData.nextStage) {
//                     nextState.stage = stateData.nextStage;
//                 }
                
//                 // Continued from previous part
//                 if (stateData.userPreferences) {
//                     // Merge new preferences with existing ones
//                     nextState.userPreferences = {
//                         ...nextState.userPreferences,
//                         genre: [...new Set([...(nextState.userPreferences.genre || []), ...(stateData.userPreferences.genre || [])])],
//                         artists: [...new Set([...(nextState.userPreferences.artists || []), ...(stateData.userPreferences.artists || [])])],
//                         tempo: stateData.userPreferences.tempo || nextState.userPreferences.tempo,
//                         purpose: stateData.userPreferences.purpose || nextState.userPreferences.purpose
//                     };
//                 }
//             } catch (parseError) {
//                 console.error("Failed to parse state analysis:", parseError);
//                 // Continue with current state if parsing fails
//             }
            
//             // Update mood in next state if detected
//             if (shouldUpdateMood && detectedMood) {
//                 nextState.contextMood = detectedMood;
                
//                 // Store mood in user profile if not guest
//                 if (userId !== "guest" && mongoose.Types.ObjectId.isValid(userId)) {
//                     try {
//                         await User.findByIdAndUpdate(userId, {
//                             $push: { moodTracking: { mood: detectedMood, date: new Date() } }
//                         });
//                     } catch (dbError) {
//                         console.error("Failed to update user mood tracking:", dbError);
//                         // Continue anyway - non-critical error
//                     }
//                 }
//             }
            
//             // Update previous responses
//             nextState.previousResponses = [
//                 ...nextState.previousResponses,
//                 userInput,
//                 aiResponse
//             ];
            
//             // Get recommendations if we're entering recommendation stage
//             let recommendations = null;
//             if (nextState.stage === 'recommendation' && currentState.stage !== 'recommendation') {
//                 try {
//                     // Decide if we should get recommendations now
//                     const shouldGetRecommendations = nextState.contextMood || 
//                         Object.values(nextState.userPreferences).some(val => 
//                             Array.isArray(val) ? val.length > 0 : Boolean(val)
//                         );
                    
//                     if (shouldGetRecommendations) {
//                         // Get music recommendations based on current context
//                         const mood = nextState.contextMood || "neutral";
//                         const genres = nextState.userPreferences.genre || [];
//                         const artists = nextState.userPreferences.artists || [];
//                         const purpose = nextState.userPreferences.purpose || null;
                        
//                         // Query the database for recommendations
//                         let query = {};
                        
//                         if (mood) {
//                             query.mood = { $regex: new RegExp(mood, 'i') };
//                         }
                        
//                         if (genres.length > 0) {
//                             query.genre = { $in: genres.map(g => new RegExp(g, 'i')) };
//                         }
                        
//                         if (artists.length > 0) {
//                             query.artist = { $in: artists.map(a => new RegExp(a, 'i')) };
//                         }
                        
//                         // Get recommendations from the database
//                         const musicResults = await MusicResource.find(query).limit(6);
                        
//                         if (musicResults.length > 0) {
//                             recommendations = musicResults.map(song => ({
//                                 musicId: song._id,
//                                 title: song.title,
//                                 artist: song.artist,
//                                 albumArt: song.albumArt,
//                                 spotifyUrl: song.spotifyUrl,
//                                 audioUrl: song.audioUrl || null,
//                                 previewUrl: song.previewUrl || null,
//                                 reason: `This ${song.genre} song matches your ${mood} mood${purpose ? ` and is great for ${purpose}` : ''}.`
//                             }));
//                         }
//                     }
//                 } catch (recError) {
//                     console.error("Error getting recommendations:", recError);
//                     // Continue without recommendations if there's an error
//                 }
//             }
            
//             // Return the response with updated state
//             res.json({
//                 response: aiResponse,
//                 mood: detectedMood,
//                 conversationState: nextState,
//                 recommendations: recommendations
//             });
            
//         } catch (apiError) {
//             console.error("Gemini AI Chat API Error:", apiError);
//             res.status(500).json({ message: "AI chat failed.", error: apiError.message });
//         }
//     } catch (err) {
//         console.error("Error in AI chat:", err);
//         res.status(500).json({ message: "Chat processing failed." });
//     }
// };

// // Function to get recommendations based on mood and preferences
// export const getRecommendations = async (mood, preferences = {}) => {
//     try {
//         const { genres = [], artists = [], tempo = null, purpose = null } = preferences;
        
//         // Build query
//         let query = {};
        
//         if (mood) {
//             query.mood = { $regex: new RegExp(mood, 'i') };
//         }
        
//         if (genres.length > 0) {
//             query.genre = { $in: genres.map(g => new RegExp(g, 'i')) };
//         }
        
//         if (artists.length > 0) {
//             query.artist = { $in: artists.map(a => new RegExp(a, 'i')) };
//         }
        
//         // Get recommendations from the database
//         const musicResults = await MusicResource.find(query).limit(8);
        
//         if (musicResults.length > 0) {
//             return musicResults.map(song => ({
//                 musicId: song._id,
//                 title: song.title,
//                 artist: song.artist,
//                 albumArt: song.albumArt,
//                 spotifyUrl: song.spotifyUrl,
//                 audioUrl: song.audioUrl || null,
//                 previewUrl: song.previewUrl || null,
//                 reason: `This ${song.genre} song matches your ${mood} mood${purpose ? ` and is great for ${purpose}` : ''}.`
//             }));
//         }
        
//         return [];
//     } catch (err) {
//         console.error("Error in getRecommendations:", err);
//         return [];
//     }
// };
</file>

<file path="controllers/leaderboardController.js">
import { getLeaderboard } from "../services/leaderboardService.js";

export const fetchLeaderBoard=async(req,res)=>{
    try{
        const {type='alltime',period='all'}=req.query;
        const entries=await getLeaderboard(type,period);
        res.json({entries});
    }catch(err){
        res.status(500).json({ message: 'Error fetching leaderboard', error: err.message });
    }
}
</file>

<file path="controllers/moodController.js">
import dotenv from "dotenv";
import mongoose from "mongoose"; // Ensure mongoose is imported
import OpenAI from "openai";
import user from "../models/user.js";
dotenv.config();

const openai = new OpenAI({ apiKey: process.env.OPENAI_API_KEY });

export const analyzeMood = async (req, res) => {
    try {
        const { userId, userInput } = req.body;
        if (!userInput) {
            return res.status(400).json({ message: "Input required!" });
        }

        // Ask GPT-4 for mood detection
        const response = await openai.chat.completions.create({
            model: "gpt-4",
            messages: [{ role: "user", content: `Detect the mood in this sentence: "${userInput}" and return a valid JSON object like { "mood": "happy" }` }],
            response_format: "json", // Ensure GPT-4 returns valid JSON
        });

        // Parse mood safely
        let detectedMood = "neutral"; // Default mood
        if (response.choices?.length > 0) {
            try {
                const moodData = JSON.parse(response.choices[0].message.content);
                detectedMood = moodData?.mood?.toLowerCase() || "neutral";
            } catch (jsonError) {
                console.error("JSON Parsing Error:", jsonError);
            }
        }

        // Store mood tracking if userId is valid
        if (userId && mongoose.Types.ObjectId.isValid(userId)) {
            await user.findByIdAndUpdate(userId, {
                $push: { moodTracking: { mood: detectedMood, date: new Date() } },
            });
        }

        res.json({
            mood: detectedMood,
            message: `You seem **${detectedMood}**. Need a song recommendation? üé∂`,
        });

    } catch (err) {
        console.error("Error analyzing mood:", err);
        res.status(500).json({ message: "Mood analysis failed. Please try again." });
    }
};


// import { GoogleGenerativeAI } from "@google/generative-ai";
// import dotenv from "dotenv";
// import mongoose from "mongoose";
// import MusicResource from "../models/MusicResource.js";
// import user from "../models/user.js";

// dotenv.config();

// // Initialize Gemini AI
// const genAI = new GoogleGenerativeAI(process.env.GEMINI_API_KEY);

// export const analyzeMood = async (req, res) => {
//     try {
//         const { userId, userInput } = req.body;
//         if (!userInput) {
//             return res.status(400).json({ message: "Input required!" });
//         }

//         // Use Gemini for mood detection
//         const model = genAI.getGenerativeModel({ model: "gemini-2.0-flash" });
        
//         const prompt = `Analyze the emotional tone in this message and identify the primary mood. 
//         Return ONLY a single word representing the dominant mood (e.g., happy, sad, anxious, excited, etc.): "${userInput}"`;
        
//         const result = await model.generateContent(prompt);
//         const detectedMood = result.response.text().trim().toLowerCase();

//         // Store mood tracking if userId is valid
//         if (userId && mongoose.Types.ObjectId.isValid(userId)) {
//             await user.findByIdAndUpdate(userId, {
//                 $push: { moodTracking: { mood: detectedMood, date: new Date() } },
//             });
//         }

//         // Get a therapeutic message related to the mood
//         const therapeuticPrompt = `As a music therapy assistant, create a brief, supportive message (1-2 sentences) 
//         for someone feeling ${detectedMood}. Be empathetic and mention that music can help with this mood.`;
        
//         const therapyResult = await model.generateContent(therapeuticPrompt);
//         const therapyMessage = therapyResult.response.text().trim();

//         res.json({
//             mood: detectedMood,
//             message: therapyMessage,
//         });

//     } catch (err) {
//         console.error("Error analyzing mood:", err);
//         res.status(500).json({ message: "Mood analysis failed. Please try again." });
//     }
// };

// export const getMoodHistory = async (req, res) => {
//     try {
//         const { userId } = req.params;
        
//         if (!userId || !mongoose.Types.ObjectId.isValid(userId)) {
//             return res.status(400).json({ message: "Valid user ID required" });
//         }
        
//         const user = await user.findById(userId);
//         if (!user) {
//             return res.status(404).json({ message: "user not found" });
//         }
        
//         // Get mood history with timestamps
//         const moodHistory = user.moodTracking || [];
        
//         res.json({
//             userId,
//             moodHistory: moodHistory.sort((a, b) => new Date(b.date) - new Date(a.date))
//         });
        
//     } catch (err) {
//         console.error("Error fetching mood history:", err);
//         res.status(500).json({ message: "Failed to fetch mood history" });
//     }
// };

// export const getMoodTrends = async (req, res) => {
//     try {
//         const { userId } = req.params;
        
//         if (!userId || !mongoose.Types.ObjectId.isValid(userId)) {
//             return res.status(400).json({ message: "Valid user ID required" });
//         }
        
//         const user = await user.findById(userId);
//         if (!user) {
//             return res.status(404).json({ message: "user not found" });
//         }
        
//         const moodHistory = user.moodTracking || [];
        
//         // Process mood data to get trends
//         const moodCounts = {};
//         const weeklyMoods = Array(7).fill(0).map(() => ({}));
        
//         const now = new Date();
        
//         moodHistory.forEach(entry => {
//             const mood = entry.mood.toLowerCase();
            
//             // Count overall moods
//             moodCounts[mood] = (moodCounts[mood] || 0) + 1;
            
//             // Get day of week (0-6, where 0 is Sunday)
//             const entryDate = new Date(entry.date);
//             const dayDiff = Math.floor((now - entryDate) / (24 * 60 * 60 * 1000));
            
//             if (dayDiff < 7) {
//                 const dayOfWeek = (now.getDay() - dayDiff + 7) % 7;
//                 weeklyMoods[dayOfWeek][mood] = (weeklyMoods[dayOfWeek][mood] || 0) + 1;
//             }
//         });
        
//         // Get top moods
//         const topMoods = Object.entries(moodCounts)
//             .sort((a, b) => b[1] - a[1])
//             .slice(0, 5)
//             .map(([mood, count]) => ({ mood, count }));
        
//         // Get weekly mood summary
//         const dayNames = ['Sunday', 'Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', 'Saturday'];
//         const weeklyMoodSummary = weeklyMoods.map((moods, index) => {
//             const topMood = Object.entries(moods).sort((a, b) => b[1] - a[1])[0];
//             return {
//                 day: dayNames[index],
//                 dominantMood: topMood ? topMood[0] : null,
//                 moodCount: topMood ? topMood[1] : 0
//             };
//         });
        
//         res.json({
//             userId,
//             topMoods,
//             weeklyMoodSummary,
//             totalMoodEntries: moodHistory.length
//         });
        
//     } catch (err) {
//         console.error("Error analyzing mood trends:", err);
//         res.status(500).json({ message: "Failed to analyze mood trends" });
//     }
// };

// export const getTherapyInsights = async (req, res) => {
//     try {
//         const { userId } = req.params;
        
//         if (!userId || !mongoose.Types.ObjectId.isValid(userId)) {
//             return res.status(400).json({ message: "Valid user ID required" });
//         }
        
//         const user = await user.findById(userId);
//         if (!user) {
//             return res.status(404).json({ message: "user not found" });
//         }
        
//         const moodHistory = user.moodTracking || [];
        
//         // Get recent moods (last 10)
//         const recentMoods = moodHistory
//             .sort((a, b) => new Date(b.date) - new Date(a.date))
//             .slice(0, 10)
//             .map(entry => entry.mood);
        
//         if (recentMoods.length === 0) {
//             return res.json({
//                 userId,
//                 insights: "Not enough mood data to generate insights.",
//                 musicRecommendation: null
//             });
//         }
        
//         // Generate insights with Gemini
//         const model = genAI.getGenerativeModel({ model: "gemini-2.0-flash" });
        
//         const insightPrompt = `As a music therapy assistant, analyze these recent moods: ${recentMoods.join(', ')}. 
        
//         Provide a short paragraph (3-4 sentences) with therapeutic insights about these mood patterns, 
//         and suggest one specific music therapy approach that might be beneficial.`;
        
//         const insightResult = await model.generateContent(insightPrompt);
//         const insights = insightResult.response.text().trim();
        
//         // Get dominant mood
//         const moodFrequency = {};
//         recentMoods.forEach(mood => {
//             moodFrequency[mood] = (moodFrequency[mood] || 0) + 1;
//         });
        
//         const dominantMood = Object.entries(moodFrequency)
//             .sort((a, b) => b[1] - a[1])[0][0];
        
//         // Get music recommendation for dominant mood
//         const musicQuery = { mood: { $regex: new RegExp(dominantMood, 'i') } };
//         const recommendedMusic = await MusicResource.findOne(musicQuery);
        
//         let musicRecommendation = null;
//         if (recommendedMusic) {
//             musicRecommendation = {
//                 title: recommendedMusic.title,
//                 artist: recommendedMusic.artist,
//                 reason: `This song may help with your recent ${dominantMood} moods.`,
//                 spotifyUrl: recommendedMusic.spotifyUrl || null
//             };
//         }
        
//         res.json({
//             userId,
//             insights,
//             dominantMood,
//             musicRecommendation
//         });
        
//     } catch (err) {
//         console.error("Error generating therapy insights:", err);
//         res.status(500).json({ message: "Failed to generate therapy insights" });
//     }
// };
</file>

<file path="controllers/musicController.js">
// // 1. First, install the spotify-web-api-node package
// // npm install spotify-web-api-node --save

// // 2. Update musicController.js with Spotify integration

// import { GoogleGenerativeAI } from "@google/generative-ai";
// import dotenv from 'dotenv';
// import mongoose from 'mongoose';
// import SpotifyWebApi from 'spotify-web-api-node';
// import MusicResource from "../models/MusicResource.js";
// import Recommendation from "../models/Recommendation.js";
// import User from "../models/User.js";
// dotenv.config();
// const genAI = new GoogleGenerativeAI(process.env.GEMINI_API_KEY);

// // Set up Spotify API client
// const spotifyApi = new SpotifyWebApi({
//   clientId: process.env.SPOTIFY_CLIENT_ID,
//   clientSecret: process.env.SPOTIFY_CLIENT_SECRET,
//   redirectUri: process.env.SPOTIFY_REDIRECT_URI
// });

// // Function to refresh Spotify access token
// async function refreshSpotifyToken() {
//   try {
//     const data = await spotifyApi.clientCredentialsGrant();
//     spotifyApi.setAccessToken(data.body['access_token']);
//     console.log('Spotify access token refreshed');
    
//     // Set timeout to refresh before token expires
//     setTimeout(refreshSpotifyToken, (data.body['expires_in'] - 60) * 1000); // Refresh 1 minute before expiry
//   } catch (error) {
//     console.error('Error refreshing Spotify token:', error);
//   }
// }

// // Initialize Spotify token on startup
// refreshSpotifyToken();

// // Function to search Spotify for a song and get track details
// async function getSpotifyTrack(title, artist) {
//   try {
//     const searchQuery = `track:${title} artist:${artist}`;
//     const searchResult = await spotifyApi.searchTracks(searchQuery, { limit: 1 });
    
//     if (searchResult.body.tracks.items.length > 0) {
//       const track = searchResult.body.tracks.items[0];
//       return {
//         spotifyId: track.id,
//         spotifyUri: track.uri,
//         previewUrl: track.preview_url,
//         spotifyUrl: track.external_urls.spotify,
//         albumArt: track.album.images[0]?.url || null,
//         popularity: track.popularity,
//         explicit: track.explicit
//       };
//     }
//     return null;
//   } catch (error) {
//     console.error('Error searching Spotify:', error);
//     return null;
//   }
// }

// // Fallback to YouTube search URL if Spotify fails
// function getYouTubeUrl(title, artist) {
//   try {
//     const searchQuery = encodeURIComponent(`${title} ${artist}`);
//     return `https://www.youtube.com/results?search_query=${searchQuery}`;
//   } catch (error) {
//     console.error('Error getting YouTube URL:', error);
//     return "";
//   }
// }

// export const getMusicRecommendations = async(req, res) => {
//     try {
//         const {userId, message, conversationHistory} = req.body;
//         console.log('Received request with:', {userId, message, conversationHistory});
        
//         // Validate userId
//         if(!userId || typeof userId !== 'string' || userId.length !== 24 || !/^[0-9a-fA-F]{24}$/.test(userId)) {
//             console.log('Invalid userId detected : ', userId);
//             return res.status(400).json({
//                 message: 'Invalid userId format',
//                 details: "Must be a 24-character hex string",
//                 receivedUserId: userId
//             });
//         }
        
//         // Convert userId to ObjectId
//         let objectId;
//         try {
//             objectId = new mongoose.Types.ObjectId(userId);
//             console.log('Converted userId:', objectId);
//         } catch(idErr) {
//             console.log('ObjectId Conversion Error:', idErr);
//             return res.status(400).json({ 
//                 message: "Invalid userId format", 
//                 details: idErr.message 
//             });
//         }

//         // Get user preferences
//         const user = await User.findById(objectId);
//         const userPreferences = user?.preferences || [];
        
//         // Get recommendations from Gemini
//         const model = genAI.getGenerativeModel({model: 'gemini-2.0-flash'});
        
//         // Build conversation context
//         const conversationContext = conversationHistory
//             ? conversationHistory.map(msg => `${msg.sender}: ${msg.text}`).join('\n')
//             : '';
            
//         const prompt = `You are a friendly and conversational music recommendation assistant. 
//         The user has previously indicated these preferences: ${userPreferences.join(', ')}.
        
//         Previous conversation:
//         ${conversationContext}
        
//         Current message: ${message}
        
//         Based on the conversation and user preferences, provide a natural, conversational response and suggest 3-5 songs that would be appropriate.
        
//         Response Format:
//         Return a JSON object with this structure:
//         {
//             "response": "Your conversational response here...",
//             "detectedMood": "mood detected from conversation",
//             "recommendations": [
//                 {
//                     "title": "Song Name",
//                     "artist": "Artist Name",
//                     "genre": "Genre",
//                     "moodTags": ["tag1", "tag2"],
//                     "duration": 240,
//                     "recommendedFor": ["activity1", "activity2"],
//                     "reason": "Why this song matches the conversation and preferences"
//                 }
//             ]
//         }
        
//         Guidelines:
//         1. Keep the response conversational and natural
//         2. Reference previous conversation when relevant
//         3. Consider user preferences in recommendations
//         4. Explain why each song was chosen
//         5. Include a mix of genres based on preferences
//         6. Make sure songs are available on Spotify/YouTube`;
        
//         const result = await model.generateContent(prompt);
//         const responseText = await result.response.text();
//         console.log('Raw Gemini Response: ', responseText);
        
//         // Parse Gemini response
//         let responseData;
//         try {
//             const jsonMatch = responseText.match(/```(?:json)?\n([\s\S]*)\n```/);
//             if (jsonMatch) {
//                 responseData = JSON.parse(jsonMatch[1]);
//             } else {
//                 responseData = JSON.parse(responseText);
//             }
//         } catch(parseError) {
//             console.error('Parsing Error:', parseError);
//             return res.status(500).json({
//                 message: "Invalid response format from Gemini",
//                 rawResponse: responseText
//             });
//         }
        
//         // Process and store recommendations
//         let recommendationsList = [];
        
//         for (const song of responseData.recommendations) {
//             // Try to get Spotify track info
//             const spotifyData = await getSpotifyTrack(song.title, song.artist);
            
//             // Fallback to YouTube if Spotify data not found
//             const audioUrl = spotifyData?.spotifyUrl || getYouTubeUrl(song.title, song.artist);
            
//             // Store the song in MusicResource
//             let music = await MusicResource.findOneAndUpdate(
//                 { title: song.title, artist: song.artist },
//                 {
//                     title: song.title,
//                     artist: song.artist,
//                     genre: song.genre,
//                     moodTags: song.moodTags || [],
//                     audioUrl: audioUrl,
//                     duration: song.duration || 0,
//                     recommendedFor: song.recommendedFor || [],
//                     ...(spotifyData && {
//                         spotifyId: spotifyData.spotifyId,
//                         spotifyUri: spotifyData.spotifyUri,
//                         previewUrl: spotifyData.previewUrl,
//                         albumArt: spotifyData.albumArt,
//                         popularity: spotifyData.popularity
//                     })
//                 },
//                 { new: true, upsert: true }
//             );
            
//             if (!music) {
//                 music = new MusicResource({
//                     title: song.title,
//                     artist: song.artist,
//                     genre: song.genre,
//                     moodTags: song.moodTags || [],
//                     audioUrl: audioUrl,
//                     duration: song.duration || 0,
//                     recommendedFor: song.recommendedFor || [],
//                     ...(spotifyData && {
//                         spotifyId: spotifyData.spotifyId,
//                         spotifyUri: spotifyData.spotifyUri,
//                         previewUrl: spotifyData.previewUrl,
//                         albumArt: spotifyData.albumArt,
//                         popularity: spotifyData.popularity
//                     })
//                 });
//                 await music.save();
//             }
            
//             recommendationsList.push({
//                 musicId: music._id,
//                 title: song.title,
//                 artist: song.artist,
//                 audioUrl: audioUrl,
//                 genre: song.genre,
//                 reason: song.reason,
//                 ...(spotifyData && {
//                     spotifyUrl: spotifyData.spotifyUrl,
//                     previewUrl: spotifyData.previewUrl,
//                     albumArt: spotifyData.albumArt
//                 })
//             });
//         }
        
//         // Save recommendation record
//         const newRecommendation = new Recommendation({
//             userId: objectId,
//             recommendedMusic: recommendationsList.map(item => ({
//                 musicId: item.musicId,
//                 reason: item.reason
//             }))
//         });
        
//         await newRecommendation.save();
        
//         return res.json({
//             response: responseData.response,
//             detectedMood: responseData.detectedMood,
//             recommendations: recommendationsList
//         });
//     } catch(err) {
//         console.log('Error finding music recommendation:', err);
//         res.status(500).json({message: 'Internal server error'});
//     }
// }


// // New endpoint to get Spotify player URL for embedding
// export const getSpotifyEmbed = async(req, res) => {
//     try {
//         const { trackId } = req.params;
        
//         if (!trackId) {
//             return res.status(400).json({ message: "Track ID is required" });
//         }
        
//         // Format the embed URL for Spotify iframes
//         const embedUrl = `https://open.spotify.com/embed/track/${trackId}`;
        
//         return res.json({
//             embedUrl: embedUrl
//         });
//     } catch(err) {
//         console.error('Error getting Spotify embed:', err);
//         res.status(500).json({ message: 'Internal server error' });
//     }
// }


// // 1. First, install the spotify-web-api-node package
// // npm install spotify-web-api-node --save

// // 2. Update musicController.js with Spotify integration

// import { GoogleGenerativeAI } from "@google/generative-ai";
// import dotenv from 'dotenv';
// import mongoose from 'mongoose';
// import SpotifyWebApi from 'spotify-web-api-node';
// import MusicResource from "../models/MusicResource.js";
// import Recommendation from "../models/Recommendation.js";
// import User from "../models/User.js";
// dotenv.config();
// const genAI = new GoogleGenerativeAI(process.env.GEMINI_API_KEY);

// // Set up Spotify API client
// const spotifyApi = new SpotifyWebApi({
//   clientId: process.env.SPOTIFY_CLIENT_ID,
//   clientSecret: process.env.SPOTIFY_CLIENT_SECRET,
//   redirectUri: process.env.SPOTIFY_REDIRECT_URI
// });

// // Function to refresh Spotify access token
// async function refreshSpotifyToken() {
//   try {
//     const data = await spotifyApi.clientCredentialsGrant();
//     spotifyApi.setAccessToken(data.body['access_token']);
//     console.log('Spotify access token refreshed');
    
//     // Set timeout to refresh before token expires
//     setTimeout(refreshSpotifyToken, (data.body['expires_in'] - 60) * 1000); // Refresh 1 minute before expiry
//   } catch (error) {
//     console.error('Error refreshing Spotify token:', error);
//   }
// }

// // Initialize Spotify token on startup
// refreshSpotifyToken();

// // Function to search Spotify for a song and get track details
// async function getSpotifyTrack(title, artist) {
//   try {
//     const searchQuery = `track:${title} artist:${artist}`;
//     const searchResult = await spotifyApi.searchTracks(searchQuery, { limit: 1 });
    
//     if (searchResult.body.tracks.items.length > 0) {
//       const track = searchResult.body.tracks.items[0];
//       return {
//         spotifyId: track.id,
//         spotifyUri: track.uri,
//         previewUrl: track.preview_url,
//         spotifyUrl: track.external_urls.spotify,
//         albumArt: track.album.images[0]?.url || null,
//         popularity: track.popularity,
//         explicit: track.explicit
//       };
//     }
//     return null;
//   } catch (error) {
//     console.error('Error searching Spotify:', error);
//     return null;
//   }
// }

// // Fallback to YouTube search URL if Spotify fails
// function getYouTubeUrl(title, artist) {
//   try {
//     const searchQuery = encodeURIComponent(`${title} ${artist}`);
//     return `https://www.youtube.com/results?search_query=${searchQuery}`;
//   } catch (error) {
//     console.error('Error getting YouTube URL:', error);
//     return "";
//   }
// }

// export const getMusicRecommendations = async(req, res) => {
//     try {
//         const {userId, message, conversationHistory} = req.body;
//         console.log('Received request with:', {userId, message, conversationHistory});
        
//         // Validate userId
//         if(!userId || typeof userId !== 'string' || userId.length !== 24 || !/^[0-9a-fA-F]{24}$/.test(userId)) {
//             console.log('Invalid userId detected : ', userId);
//             return res.status(400).json({
//                 message: 'Invalid userId format',
//                 details: "Must be a 24-character hex string",
//                 receivedUserId: userId
//             });
//         }
        
//         // Convert userId to ObjectId
//         let objectId;
//         try {
//             objectId = new mongoose.Types.ObjectId(userId);
//             console.log('Converted userId:', objectId);
//         } catch(idErr) {
//             console.log('ObjectId Conversion Error:', idErr);
//             return res.status(400).json({ 
//                 message: "Invalid userId format", 
//                 details: idErr.message 
//             });
//         }

//         // Get user preferences
//         const user = await User.findById(objectId);
//         const userPreferences = user?.preferences || [];
        
//         // Get recommendations from Gemini
//         const model = genAI.getGenerativeModel({model: 'gemini-2.0-flash'});
        
//         // Build conversation context
//         const conversationContext = conversationHistory
//             ? conversationHistory.map(msg => `${msg.sender}: ${msg.text}`).join('\n')
//             : '';
            
//         const prompt = `You are a friendly and conversational music recommendation assistant. 
//         The user has previously indicated these preferences: ${userPreferences.join(', ')}.
        
//         Previous conversation:
//         ${conversationContext}
        
//         Current message: ${message}
        
//         Based on the conversation and user preferences, provide a natural, conversational response and suggest 3-5 songs that would be appropriate.
        
//         Response Format:
//         Return a JSON object with this structure:
//         {
//             "response": "Your conversational response here...",
//             "detectedMood": "mood detected from conversation",
//             "recommendations": [
//                 {
//                     "title": "Song Name",
//                     "artist": "Artist Name",
//                     "genre": "Genre",
//                     "moodTags": ["tag1", "tag2"],
//                     "duration": 240,
//                     "recommendedFor": ["activity1", "activity2"],
//                     "reason": "Why this song matches the conversation and preferences"
//                 }
//             ]
//         }
        
//         Guidelines:
//         1. Keep the response conversational and natural
//         2. Reference previous conversation when relevant
//         3. Consider user preferences in recommendations
//         4. Explain why each song was chosen
//         5. Include a mix of genres based on preferences
//         6. Make sure songs are available on Spotify/YouTube`;
        
//         const result = await model.generateContent(prompt);
//         const responseText = await result.response.text();
//         console.log('Raw Gemini Response: ', responseText);
        
//         // Parse Gemini response
//         let responseData;
//         try {
//             const jsonMatch = responseText.match(/```(?:json)?\n([\s\S]*)\n```/);
//             if (jsonMatch) {
//                 responseData = JSON.parse(jsonMatch[1]);
//             } else {
//                 responseData = JSON.parse(responseText);
//             }
//         } catch(parseError) {
//             console.error('Parsing Error:', parseError);
//             return res.status(500).json({
//                 message: "Invalid response format from Gemini",
//                 rawResponse: responseText
//             });
//         }
        
//         // Process and store recommendations
//         let recommendationsList = [];
        
//         for (const song of responseData.recommendations) {
//             // Try to get Spotify track info
//             const spotifyData = await getSpotifyTrack(song.title, song.artist);
            
//             // Fallback to YouTube if Spotify data not found
//             const audioUrl = spotifyData?.spotifyUrl || getYouTubeUrl(song.title, song.artist);
            
//             // Store the song in MusicResource
//             let music = await MusicResource.findOneAndUpdate(
//                 { title: song.title, artist: song.artist },
//                 {
//                     title: song.title,
//                     artist: song.artist,
//                     genre: song.genre,
//                     moodTags: song.moodTags || [],
//                     audioUrl: audioUrl,
//                     duration: song.duration || 0,
//                     recommendedFor: song.recommendedFor || [],
//                     ...(spotifyData && {
//                         spotifyId: spotifyData.spotifyId,
//                         spotifyUri: spotifyData.spotifyUri,
//                         previewUrl: spotifyData.previewUrl,
//                         albumArt: spotifyData.albumArt,
//                         popularity: spotifyData.popularity
//                     })
//                 },
//                 { new: true, upsert: true }
//             );
            
//             if (!music) {
//                 music = new MusicResource({
//                     title: song.title,
//                     artist: song.artist,
//                     genre: song.genre,
//                     moodTags: song.moodTags || [],
//                     audioUrl: audioUrl,
//                     duration: song.duration || 0,
//                     recommendedFor: song.recommendedFor || [],
//                     ...(spotifyData && {
//                         spotifyId: spotifyData.spotifyId,
//                         spotifyUri: spotifyData.spotifyUri,
//                         previewUrl: spotifyData.previewUrl,
//                         albumArt: spotifyData.albumArt,
//                         popularity: spotifyData.popularity
//                     })
//                 });
//                 await music.save();
//             }
            
//             recommendationsList.push({
//                 musicId: music._id,
//                 title: song.title,
//                 artist: song.artist,
//                 audioUrl: audioUrl,
//                 genre: song.genre,
//                 reason: song.reason,
//                 ...(spotifyData && {
//                     spotifyUrl: spotifyData.spotifyUrl,
//                     previewUrl: spotifyData.previewUrl,
//                     albumArt: spotifyData.albumArt
//                 })
//             });
//         }
        
//         // Save recommendation record
//         const newRecommendation = new Recommendation({
//             userId: objectId,
//             recommendedMusic: recommendationsList.map(item => ({
//                 musicId: item.musicId,
//                 reason: item.reason
//             }))
//         });
        
//         await newRecommendation.save();
        
//         return res.json({
//             response: responseData.response,
//             detectedMood: responseData.detectedMood,
//             recommendations: recommendationsList
//         });
//     } catch(err) {
//         console.log('Error finding music recommendation:', err);
//         res.status(500).json({message: 'Internal server error'});
//     }
// }


// // New endpoint to get Spotify player URL for embedding
// export const getSpotifyEmbed = async(req, res) => {
//     try {
//         const { trackId } = req.params;
        
//         if (!trackId) {
//             return res.status(400).json({ message: "Track ID is required" });
//         }
        
//         // Format the embed URL for Spotify iframes
//         const embedUrl = `https://open.spotify.com/embed/track/${trackId}`;
        
//         return res.json({
//             embedUrl: embedUrl
//         });
//     } catch(err) {
//         console.error('Error getting Spotify embed:', err);
//         res.status(500).json({ message: 'Internal server error' });
//     }
// }


import { GoogleGenerativeAI } from "@google/generative-ai";
import dotenv from 'dotenv';
import mongoose from "mongoose";
import SpotifyWebApi from 'spotify-web-api-node';
import user from '../models/user.js';
// controllers/userFeedbackController.js
import axios from "axios";
import querystring from 'querystring';
import MusicResource from "../models/MusicResource.js";
import Recommendation from '../models/Recommendation.js';
dotenv.config();
const genAI = new GoogleGenerativeAI(process.env.GEMINI_API_KEY);

// Set up Spotify API client
const spotifyApi = new SpotifyWebApi({
  clientId: process.env.SPOTIFY_CLIENT_ID,
  clientSecret: process.env.SPOTIFY_CLIENT_SECRET,
  redirectUri: process.env.SPOTIFY_REDIRECT_URI
});
let tokenExpiryTime = 0;
// Function to refresh Spotify access token
async function refreshSpotifyToken() {
 try {
    console.log('Attempting to refresh Spotify token...');
    const data = await spotifyApi.clientCredentialsGrant();
    
    spotifyApi.setAccessToken(data.body['access_token']);
    tokenExpiryTime = Date.now() + (data.body['expires_in'] * 1000);
    
    console.log('Spotify access token refreshed successfully');
    console.log(`Token expires at: ${new Date(tokenExpiryTime).toISOString()}`);
    
    // Set timeout to refresh 5 minutes before token expires
    const refreshTime = (data.body['expires_in'] - 300) * 1000; // 5 minutes before expiry
    setTimeout(refreshSpotifyToken, Math.max(refreshTime, 60000)); // At least 1 minute
    
  } catch (error) {
    console.error('Error refreshing Spotify token:', error.message);
    // Retry after 30 seconds if refresh fails
    setTimeout(refreshSpotifyToken, 30000);
  }
}

// Initialize Spotify token on startup
refreshSpotifyToken();


async function getSpotifyTrack(title, artist) {
    try {
      // Try exact match first
      let searchQuery = `track:${title} artist:${artist}`;
      let searchResult = await spotifyApi.searchTracks(searchQuery, { limit: 1 });
      
      // If no results, try a more lenient search
      if (searchResult.body.tracks.items.length === 0) {
        // Remove any text in parentheses or after feat./ft.
        const cleanTitle = title.replace(/\(.*?\)|\sfeat\..*|\sft\..*$/i, '').trim();
        const cleanArtist = artist.replace(/\(.*?\)|\sfeat\..*|\sft\..*$/i, '').trim();
        
        searchQuery = `${cleanTitle} ${cleanArtist}`;
        searchResult = await spotifyApi.searchTracks(searchQuery, { limit: 5 });
      }
      
      if (searchResult.body.tracks.items.length > 0) {
        const track = searchResult.body.tracks.items[0];
        return {
          spotifyId: track.id,
          spotifyUri: track.uri,
          spotifyUrl: track.external_urls.spotify,
          previewUrl: track.preview_url,
          albumArt: track.album.images[0]?.url || null,
          popularity: track.popularity,
          explicit: track.explicit
        };
      }
      
      console.log(`No Spotify tracks found for "${title}" by ${artist}`);
      return null;
    } catch (error) {
      console.error('Error searching Spotify:', error);
      return null;
    }
  }
  

// Fallback to YouTube search URL if Spotify fails
function getYouTubeUrl(title, artist) {
  try {
    const searchQuery = encodeURIComponent(`${title} ${artist}`);
    return `https://www.youtube.com/results?search_query=${searchQuery}`;
  } catch (error) {
    console.error('Error getting YouTube URL:', error);
    return "";
  }
}
// Helper function to preprocess JSON string
function preprocessJsonString(jsonStr) {
    // Fix time formats (e.g., 4:36 ‚Üí 276 or "4:36")
    return jsonStr.replace(/"duration":\s*(\d+):(\d+)/g, (match, minutes, seconds) => {
        // Convert to seconds as a number
        const totalSeconds = parseInt(minutes) * 60 + parseInt(seconds);
        return `"duration": ${totalSeconds}`;
        
        // Alternatively, return as a string:
        // return `"duration": "${minutes}:${seconds}"`;
    });
}

export const getMusicRecommendations = async(req, res) => {
    try {
        const {userId, message, conversationHistory} = req.body;
        console.log('Received request with:', {userId, message, conversationHistory});
         // Convert userId to ObjectId
         let objectId;
         try {
             objectId = new mongoose.Types.ObjectId(userId);
             console.log('Converted userId:', objectId);
         } catch(idErr) {
             console.log('ObjectId Conversion Error:', idErr);
             return res.status(400).json({ 
                 message: "Invalid userId format", 
                 details: idErr.message 
             });
         }
        // Get user preferences
        const User = await user.findById(objectId);
        // Validate userId
        if(!userId || typeof userId !== 'string' || userId.length !== 24 || !/^[0-9a-fA-F]{24}$/.test(userId)) {
            console.log('Invalid userId detected : ', userId);
            return res.status(400).json({
                message: 'Invalid userId format',
                details: "Must be a 24-character hex string",
                receivedUserId: userId
            });
        }
        
       

   
        if (!User) {
            return res.status(404).json({
                message: "User not found",
                details: "The provided userId does not exist in the database"
            });
        }
        const userPreferences = User.preferences || [];
        
        // Get recommendations from Gemini
        const model = genAI.getGenerativeModel({model: 'gemini-2.0-flash'});
        
        // Build conversation context
        const conversationContext = conversationHistory
            ? conversationHistory.map(msg => `${msg.sender}: ${msg.text}`).join('\n')
            : '';
            
        const prompt = `You are a friendly and conversational music recommendation assistant. 
         You are built by RISHIRAJ an undergrad at NSUT to provide users ease in finding and compiling music.
        The user has previously indicated these preferences: ${userPreferences.join(', ')}.
        
        Previous conversation:
        ${conversationContext}
        
        Current message: ${message}
        
        Based on the conversation and user preferences, provide a natural, conversational response and suggest as many songs as asked by user and if not specified suggest 4-5 songs that would be appropriate.
        
        Response Format:
        Return a JSON object with this structure:
        {
            "response": "Your conversational response here...",
            "detectedMood": "mood detected from conversation",
            "recommendations": [
  { 
    "title": "Song Name",
    "artist": "Artist Name",
    "genre": "Genre",
    "moodTags": ["tag1", "tag2"],
    "duration": 240,
    "recommendedFor": ["activity1", "activity2"],
                    "reason": "Why this song matches the conversation and preferences"
                }
            ]
        }
        
        Guidelines:
        1. Keep the response conversational and natural
        2. Reference previous conversation when relevant
        3. Consider user preferences in recommendations
        4. Explain why each song was chosen
        5. Include a mix of genres based on preferences
        6. Make sure songs are available on Spotify/YouTube`;
        
        const result = await model.generateContent(prompt);
        const responseText = await result.response.text();
        console.log('Raw Gemini Response: ', responseText);
        
        let responseData;
        try {
            // Extract JSON from code blocks if present
            const jsonMatch = responseText.match(/```json\n([\s\S]*?)\n```/);
            const jsonString = jsonMatch ? jsonMatch[1] : responseText;
            
            // Pre-process the JSON string to fix common formatting issues
            const preprocessedJson = preprocessJsonString(jsonString);
            
            // Parse the preprocessed JSON
            responseData = JSON.parse(preprocessedJson);
        } catch(parseError) {
            console.error('Parsing Error:', parseError);
            return res.status(500).json({
                message: "Invalid response format from Gemini",
                rawResponse: responseText
            });
        }
        // Process and store recommendations
        let recommendationsList = [];
        
        for (const song of responseData.recommendations) {
            // Try to get Spotify track info
            const spotifyData = await getSpotifyTrack(song.title, song.artist);
              // Logging for debugging
    if (spotifyData) {
        console.log(`Spotify data for "${song.title}" by ${song.artist}:`, {
          id: spotifyData.spotifyId,
          uri: spotifyData.spotifyUri,
          url: spotifyData.spotifyUrl
        });
      } else {
        console.log(`No Spotify data found for "${song.title}" by ${song.artist}`);
      }
            // Fallback to YouTube if Spotify data not found
            const audioUrl = spotifyData?.spotifyUrl || getYouTubeUrl(song.title, song.artist);
            
            // Store the song in MusicResource
            let music = await MusicResource.findOneAndUpdate(
                { title: song.title, artist: song.artist },
                {
                    title: song.title,
                    artist: song.artist,
                    genre: song.genre,
                    moodTags: song.moodTags || [],
                    audioUrl: audioUrl,
                    duration: song.duration || 0,
                    recommendedFor: song.recommendedFor || [],
                    ...(spotifyData && {
                        spotifyId: spotifyData.spotifyId,
                        spotifyUri: spotifyData.spotifyUri,  // URI format: spotify:track:xyz
                        spotifyUrl: spotifyData.spotifyUrl,
                        previewUrl: spotifyData.previewUrl,
                        albumArt: spotifyData.albumArt,
                        popularity: spotifyData.popularity
                    })
                },
                { new: true, upsert: true }
            );
            
            if (!music) {
                music = new MusicResource({
                    title: song.title,
                    artist: song.artist,
                    genre: song.genre,
                    moodTags: song.moodTags || [],
                    audioUrl: audioUrl,
                    duration: song.duration || 0,
                    recommendedFor: song.recommendedFor || [],
                    ...(spotifyData && {
                        spotifyId: spotifyData.spotifyId,
                        spotifyUri: spotifyData.spotifyUri,  // URI format: spotify:track:xyz
                        spotifyUrl: spotifyData.spotifyUrl,
                        previewUrl: spotifyData.previewUrl,
                        albumArt: spotifyData.albumArt,
                        popularity: spotifyData.popularity
                    })
                });
                await music.save();
            }
            
            recommendationsList.push({
                musicId: music._id,
                title: song.title,
                artist: song.artist,
                audioUrl: audioUrl,
                genre: song.genre,
                reason: song.reason,
                ...(spotifyData && {
                    spotifyId: spotifyData?.spotifyId || null, // Add this
                    spotifyUrl: spotifyData?.spotifyUrl || null, // Make sure this is the full URL
                    spotifyUri: spotifyData?.spotifyUri || null, // Include the URI format
                    previewUrl: spotifyData.previewUrl,
                    albumArt: spotifyData.albumArt
                })
            });
        }
        
        // Save recommendation record
        const newRecommendation = new Recommendation({
            userId: objectId,
            recommendedMusic: recommendationsList.map(item => ({
                musicId: item.musicId,
                reason: item.reason
            }))
        });
        
        await newRecommendation.save();
        
        return res.json({
            response: responseData.response,
            detectedMood: responseData.detectedMood,
            recommendations: recommendationsList
        });
    } catch(err) {
        console.log('Error finding music recommendation:', err);
        res.status(500).json({message: 'Internal server error'});
    }
}


// New endpoint to get Spotify player URL for embedding
export const getSpotifyEmbed = async(req, res) => {
    try {
        const { trackId } = req.params;
        
        if (!trackId) {
            return res.status(400).json({ message: "Track ID is required" });
        }
        
        // Format the embed URL for Spotify iframes
        const embedUrl = `https://open.spotify.com/embed/track/${trackId}`;
        
        return res.json({
            embedUrl: embedUrl
        });
    } catch(err) {
        console.error('Error getting Spotify embed:', err);
        res.status(500).json({ message: 'Internal server error' });
    }
}


//Get spotify auth URL
export const getSpotifyAuthUrl = async (req, res) => {
    const clientId = process.env.SPOTIFY_CLIENT_ID;
    const redirectUri = 'http://localhost:5173/spotify-callback';
    const scopes=[
        'streaming',
        'user-read-email',
        'user-read-private',
        'user-modify-playback-state',
        'user-read-playback-state',
        'user-library-read',
        'playlist-read-private',
    ];
    const state=Math.random().toString(36).substring(2, 15);
    const authUrl='https://accounts.spotify.com/authorize?' +
    querystring.stringify({
      response_type: 'code',
      client_id: clientId,
      scope: scopes.join(' '),
      redirect_uri: redirectUri,
      state: state
    });
    res.json({authUrl});
}
// Handle Spotify callback
export const handleSpotifyCallback = async (req, res) => {
  try {
    const { code } = req.query;
    const clientId = process.env.SPOTIFY_CLIENT_ID;
    const clientSecret = process.env.SPOTIFY_CLIENT_SECRET;
    const redirectUri = 'http://localhost:5173/spotify-callback';
    
    // Exchange code for tokens
    const response = await axios.post('https://accounts.spotify.com/api/token', 
      querystring.stringify({
        grant_type: 'authorization_code',
        code,
        redirect_uri: redirectUri
      }),
      {
        headers: {
          'Content-Type': 'application/x-www-form-urlencoded',
          'Authorization': 'Basic ' + Buffer.from(clientId + ':' + clientSecret).toString('base64')
        }
      }
    );
    
    const { access_token, refresh_token, expires_in } = response.data;
    
    res.json({
      accessToken: access_token,
      refreshToken: refresh_token,
      expiresIn: expires_in
    });
  } catch (error) {
    console.error('Spotify callback error:', error);
    res.status(500).json({ message: 'Failed to authenticate with Spotify' });
  }
};
</file>

<file path="controllers/playlistController.js">
import crypto from 'crypto';
import QRCode from 'qrcode';
import MusicResource from "../models/MusicResource.js";
import Playlist from "../models/Playlist.js";
import User from '../models/user.js';
// export const createPlaylist = async (req, res) => {
//     try {
//         const userId = req.user._id;
//         const { name } = req.body;
      
//       // Convert userId string to MongoDB ObjectId
//       const userObjectId = new mongoose.Types.ObjectId(userId);
      
//       const newPlaylist = new Playlist({ 
//         userId: userObjectId, 
//         name, 
//         songs: [] 
//       });
      
//       await newPlaylist.save();
//       res.status(201).json(newPlaylist);
//     } catch (err) {
//       console.error("Error creating playlist:", err);
//       res.status(500).json({ message: 'Error creating playlist', error: err.message });
//     }
//   };

//INVITE BY USERNAME
export const inviteByUsername=async(req,res)=>{
    try{
        const ownerId=req.user._id;
        const {playlistId,username}=req.body;
        //Find the playlist and verify ownership
        const playlist=await Playlist.findOne({_id:playlistId,userId:ownerId});
        if(!playlist){
            return res.status(404).json({message: 'Playlist not found or you do not have permission'});
        }
        //Find user to invite
        const userToInvite=await User.findOne({name: username});
        if(!userToInvite){
            return res.status(404).json({ message: "User not found" });
        }
        //Check if user is already a collaborator
        if(playlist.collaborators && playlist.collaborators.some(id=> id.toString()===userToInvite._id.toString())){
            return res.status(400).json({ message: "User is already a collaborator" });
        }
        //Add user as a collaborator
        if(!playlist.collaborators){
            playlist.collaborators=[];
        }
        playlist.collaborators.push(userToInvite._id);
        await playlist.save();

        if(req.io){
            //Notify all users in the room about the new collaborator
            req.io.to(`playlist:${playlistId}`).emit('collaborator_added',{
                playlistId,
                collaborator:{
                    userId:userToInvite._id,
                    username: userToInvite.name
                },
                addedBy:{
                    userId:ownerId,
                    username:req.user.name
                }
            });
              // Notify the invited user directly
            req.io.to(`user:${userToInvite._id}`).emit('collaborator_added', {
                playlistId,
                collaborator: {
                    userId: userToInvite._id,
                    username: userToInvite.name
                },
                addedBy: {
                    userId: ownerId,
                    username: req.user.name
                }
            });
        }
        res.status(200).json({ 
            message: "Collaborator added successfully", 
            collaborator: {
                _id: userToInvite._id,
                name: userToInvite.name
            }
        });
    }catch(err){
        console.error("Error inviting collaborator:", err);
        res.status(500).json({ message: 'Error inviting collaborator', error: err.message });
    }
}

//Generate or refresh invite link
export const generateInviteLink=async(req,res)=>{
    try{
        const ownerId=req.user._id;
        const {playlistId}=req.params;
        // Find the playlist and verify ownership
        const playlist = await Playlist.findOne({ _id: playlistId, userId: ownerId });
        if (!playlist) {
            return res.status(404).json({ message: "Playlist not found or you don't have permission" });
        }
        //Generate new invite link
        const inviteCode=crypto.randomBytes(6).toString('hex');
        playlist.inviteLink={
            code:inviteCode,
            expiresAt: new Date(Date.now() + 7 * 24 * 60 * 60 * 1000) 
        }
        await playlist.save();
        //Generate full invite URL
        const baseUrl='http://localhost:5173' || process.env.FRONTEND_URL ;
        const inviteUrl=`${baseUrl}/invite/${inviteCode}`;
        res.status(200).json({ 
            message: "Invite link generated successfully",
            inviteLink: inviteUrl,
            expiresAt: playlist.inviteLink.expiresAt
        });
    }catch(err){
        console.error("Error generating invite link:", err);
        res.status(500).json({ message: 'Error generating invite link', error: err.message });
    }
}

//Generate QRCode for invitation
export const generateInviteQR=async(req,res)=>{
    try{
        const ownerId = req.user._id;
        const { playlistId } = req.params;
        
        // Find the playlist and verify ownership
        const playlist = await Playlist.findOne({ _id: playlistId, userId: ownerId });
        if (!playlist) {
            return res.status(404).json({ message: "Playlist not found or you don't have permission" });
        }
        //Generate or use existing invite code
        let inviteCode=playlist.inviteLink?.code;
        if(!inviteCode){
            inviteCode = crypto.randomBytes(6).toString('hex');
            playlist.inviteLink = {
                code: inviteCode,
                expiresAt: new Date(Date.now() + 7 * 24 * 60 * 60 * 1000) // 7 days
            };
            await playlist.save();
        }
        //Generate full invite URL
        const baseUrl=process.env.FRONTEND_URL || 'http://localhost:5173';
        const inviteUrl = `${baseUrl}/invite/${inviteCode}`;
        const qrCodeDataURL=await QRCode.toDataURL(inviteUrl);
        res.status(200).json({ 
            message: "QR code generated successfully",
            inviteLink: inviteUrl,
            qrCode: qrCodeDataURL,
            expiresAt: playlist.inviteLink.expiresAt
        });

    }catch(err){
        console.error("Error generating QR code:", err);
        res.status(500).json({ message: 'Error generating QR code', error: err.message });
    }
}
//Accept invitation by code
export const acceptInvitation=async(req,res)=>{
    try{
        const userId=req.user._id;
        const {inviteCode}=req.params;
        //Find playlist with matching invitation and valid expiration 
        const playlist=await Playlist.findOne({'inviteLink.code':inviteCode,
            'inviteLink.expiresAt':{$gt: new Date()}
        });
        if(!playlist){
            return res.status(404).json({ message: "Invalid or expired invitation link" });
        }
        // Check if user is already a collaborator
        if (playlist.collaborators && playlist.collaborators.some(id => id.toString() === userId.toString())) {
            return res.status(200).json({ message: "You are already a collaborator on this playlist", playlistId: playlist._id });
        }
        // Add user to collaborators
        if (!playlist.collaborators) {
            playlist.collaborators = [];
        }
        
        playlist.collaborators.push(userId);
        await playlist.save();

        //Get user info for socket event
        const user=await User.findById(userId);
        //Emit socket event if socket is available
        if(req.io){
            //Join the user to the socket room
            req.io.to(`playlist:${playlist._id}`).emit('user_joined',{
                userId:userId,username:user.name,
                joinedVia:'invitation'
            });
        }
        
        res.status(200).json({ 
            message: "Successfully joined playlist as collaborator",
            playlistId: playlist._id
        });
        
    }catch(err){
        console.error("Error accepting invitation:", err);
        res.status(500).json({ message: 'Error accepting invitation', error: err.message });
    }
}

//Get all collaborators for a playlist
export const getCollaborators=async(req,res)=>{
    try{
        const userId=req.user._id;
        const {playlistId}=req.params;
        const playlist=await Playlist.findOne({
            _id:playlistId,
            $or:[{ userId:userId},
                {collaborators: userId}
            ]
        }).populate('collaborators','name email');
        if(!playlist){
            return res.status(404).json({message:"Playlist not found or you don't have access"});
        }
        res.status(200).json({ collaborators: playlist.collaborators || [] });
    }catch(err){
        console.error("Error getting collaborators:", err);
        res.status(500).json({ message: 'Error getting collaborators', error: err.message });
    }
}

//Remove collaborators function
export const removeCollaborator=async(req,res)=>{
    try{
        const ownerId=req.user._id;
        const {playlistId,userId}=req.params;
        //Find the playlist and verify ownership
        const playlist = await Playlist.findOne({ _id: playlistId, userId: ownerId });
        if(!playlist){
            return res.status(404).json({message:"Playlist not found or you don't have permission"});
        }

        //Get collaborator info before removing
        const collaborator=await User.findById(userId);
        if(!collaborator){
            return res.status(404).json({message: 'Collaborator not found'});
        }
        //Removing user from collaborator
        if(!playlist.collaborators || !playlist.collaborators.some(id=> id.toString() === userId.toString())){
            return res.status(400).json({ message: "User is not a collaborator on this playlist" });
        }

        //Remove user from collaborators
        playlist.collaborators=playlist.collaborators.filter(id=>id.toString() !==userId.toString());
        await playlist.save();

        //Emit socket event if socket is available
        if(req.io){
            req.io.to(`playlist:${playlistId}`).emit('collaborator_removed',{
                playlistId,
                removedCollaborator: {
                    userId: collaborator._id,
                    username: collaborator.name
                },
                removedBy: {
                    userId: ownerId,
                    username: req.user.name
                }
            });
        }
        //Notify the removed user personally 
        req.io.to(`user:${collaborator._id}`).emit('collaborator_removed',{
                playlistId,
                removedCollaborator: {
                    userId: collaborator._id,
                    username: collaborator.name
                },
                removedBy: {
                    userId: ownerId,
                    username: req.user.name
                }
            });
        res.status(200).json({ message: "Collaborator removed successfully" });
    }catch(err){
        console.log('Error removing collaborator',err);
        res.status(500).json({message:'Error removing collaborator',error:err.message});
    }
}

export const addSongToPlaylist = async (req, res) => {
    try {
        const userId = req.user._id;
        const { playlistId, songId } = req.body;
        const song = await MusicResource.findById(songId);
        if (!song) {
            return res.status(404).json({ message: 'Song not found' });
        }
        // const playlist = await Playlist.findById(playlistId);
        // First check if playlist belongs to user of if the user is a collaborator
        const playlist = await Playlist.findOne({ 
            _id: playlistId,
            $or:[{userId: userId},
                {collaborators:userId}
            ]
        });
        if (!playlist) {
            return res.status(404).json({ message: "Playlist not found" });
        }

        const existingSong = playlist.songs.find(playlistSong => 
            playlistSong.musicId.toString() === songId.toString()
        );
        
        if (existingSong) {
            return res.status(409).json({ 
                message: 'Song already exists in this playlist',
                type: 'duplicate_song',
                songTitle: song.title,
                artist: song.artist,
                playlistName: playlist.name
            });
        }

        playlist.songs.push({
            musicId: song._id,
            title: song.title,
            artist: song.artist,
            audioUrl: song.audioUrl,
            genre: song.genre,
            spotifyUri: song.spotifyUri, // <-- Critical addition
            albumArt: song.albumArt,     // <-- Critical addition
            reason: 'Added by user'
        });
        await playlist.save();

        //Emit socket event if socket is available
        if(req.io){
            req.io.to(`playlist:${playlistId}`).emit('song_added',{
                playlistId,
                song:{
                    musicId: song._id,
                    title:song.title,
                    artist:song.artist
                },
                addedBy:{
                    userId,
                    username:req.user.name
                }
            });
        }
        console.log('PLAYLIST SONGS:',playlist.songs);
        res.status(200).json(playlist);
    } catch (err) {
        res.status(500).json({ message: 'Error adding song to playlist', err });
    }
};

// export const removeSongFromPlaylist = async (req, res) => {
//     try {
//         console.log('BACKEND');
//         const { musicId } = req.body;
//         const { playlistId } = req.body;
//         const playlist = await Playlist.findById(playlistId);
//         if (!playlist) {
//             return res.status(404).json({ message: "Playlist not found" });
//         }
//         playlist.songs = playlist.songs.filter(song => song.musicId.toString() !== musicId);
//         console.log('Song deleted');
//         await playlist.save();
//         res.status(200).json({ message: "Song removed successfully" });
//     } catch (err) {
//         res.status(500).json({ message: 'Error removing song from playlist', err });
//     }
// };
export const removeSongFromPlaylist = async (req, res) => {
    try {
        console.log('BACKEND');
        const userId = req.user._id;
        const { musicId, playlistId } = req.body;
        
       // Check if user is owner or collaborator
        const playlist = await Playlist.findOne({ 
            _id: playlistId,
            $or: [
                { userId: userId },
                { collaborators: userId }
            ]
        });
        
        if (!playlist) {
            return res.status(404).json({ message: "Playlist not found or you don't have permission" });
        }
        
        playlist.songs = playlist.songs.filter(song => song.musicId.toString() !== musicId);
        console.log('Song deleted');
        await playlist.save();

        //Emit socket event if socket is available
        if(req.io){
            req.io.to(`playlist:${playlistId}`).emit('song_removed',{
                playlistId,
                songId:musicId,
                removedBy:{
                    userId,
                    username: req.user.name
                }
            });
        }
        res.status(200).json({ message: "Song removed successfully" });
    } catch (err) {
        res.status(500).json({ message: 'Error removing song from playlist', err });
    }
};


// export const deletePlaylist = async (req, res) => {
//     try {
//         const { playlistId } = req.params;
//         await Playlist.findByIdAndDelete(playlistId);
//         res.status(200).json({ message: "Playlist deleted successfully" });
//     } catch (err) {
//         res.status(500).json({ message: 'Error deleting playlist', err });
//     }
// };
export const deletePlaylist = async (req, res) => {
    try {
        const userId = req.user._id;
        const { playlistId } = req.params;
        
        // Find the playlist and verify ownership
        const playlist = await Playlist.findOne({ 
            _id: playlistId,
            userId: userId
        });
        
        if (!playlist) {
            return res.status(404).json({ message: "Playlist not found or you don't have permission" });
        }
        
        await Playlist.findByIdAndDelete(playlistId);
        res.status(200).json({ message: "Playlist deleted successfully" });
    } catch (err) {
        res.status(500).json({ message: 'Error deleting playlist', error: err.message });
    }
};


// export const getUserPlaylists = async (req, res) => {
//     try {
//       const { userId } = req.params;
//        // Validate userId format
//        if (!userId || typeof userId !== 'string' || userId.length !== 24) {
//         return res.status(400).json({ message: 'Invalid userId format' });
//     }
      
//       // Convert userId string to MongoDB ObjectId
//       const userObjectId = new mongoose.Types.ObjectId(userId);
      
//       const playlists = await Playlist.find({ userId: userObjectId });
//       res.status(200).json(playlists);
//     } catch (err) {
//       console.error("Error fetching playlists:", err);
//       res.status(500).json({ message: 'Error fetching playlists', error: err.message });
//     }
//   };
export const createPlaylist = async (req, res) => {
    try {
        const userId = req.user._id;
        const { name } = req.body;
        
        console.log("Creating playlist for user:", userId);
        
        const newPlaylist = new Playlist({ 
            userId: userId, 
            name, 
            songs: [] 
        });
        
        await newPlaylist.save();
        console.log("Created new playlist:", newPlaylist);
        
        res.status(201).json(newPlaylist);
    } catch (err) {
        console.error("Error creating playlist:", err);
        res.status(500).json({ message: 'Error creating playlist', error: err.message });
    }
};

// export const getUserPlaylists = async (req, res) => {
//     try {
//         const userId = req.user._id;
//         // Log the exact format of the userId
//         console.log("Getting playlists for user (raw):", userId);
//         console.log("User ID type:", typeof userId);
        
//         // If userId is a string, convert it to ObjectId
//         // const userIdObj = typeof userId === 'string' 
//         //     ? new mongoose.Types.ObjectId(userId) 
//         //     : userId;
            
//         // console.log("User ID after conversion:", userIdObj);
        
//         const playlists = await Playlist.find({ userId: userId });
        
//         // Log each playlist's userId for debugging
//         // playlists.forEach(playlist => {
//         //     console.log(`Playlist ${playlist._id} belongs to user ${playlist.userId}`);
//         // });
        
//         res.status(200).json(playlists);
//     } catch (err) {
//         console.error("Error fetching playlists:", err);
//         res.status(500).json({ message: 'Error fetching playlists', error: err.message });
//     }
// };
export const getUserPlaylists = async (req, res) => {
    try {
        const userId = req.user._id;
        console.log("Getting playlists for user:", userId);
        
        //Find the playlists where the user is the owner or the collaborator
        const playlists=await Playlist.find({ $or:[
            {userId:userId},
            {collaborators:userId}
        ]});
        //Add a property to denote whether the user is a collaborator or the owner of the playlist
        const enhancedPlaylists=playlists.map(playlist=>{
            const isOwner=playlist.userId.toString()===userId.toString();
            return {
                ...playlist.toObject(),
                isOwner,
                isCollaborator: !isOwner
            }
        });
        res.status(200).json(enhancedPlaylists);
    } catch (err) {
        console.error("Error fetching playlists:", err);
        res.status(500).json({ message: 'Error fetching playlists', error: err.message });
    }
};



// Add this new function to your existing controller
export const createPlaylistFromVoice = async (req, res) => {
    try {
        const userId = req.user._id;
        const { command ,conversationHistory = []} = req.body;
        
        if (!command || typeof command !== 'string') {
            return res.status(400).json({ 
                message: 'Invalid voice command provided' 
            });
        }
        
        console.log(`Processing voice command: "${command}" for user:`, userId);
        
        // Extract playlist name from command
        let playlistName = '';
        let playlistType = null;
        
        // Common playlist types to detect
        const playlistTypes = {
            workout: ['workout', 'exercise', 'fitness', 'gym'],
            relaxation: ['relax', 'calm', 'chill', 'meditation', 'sleep'],
            focus: ['focus', 'study', 'concentration', 'work'],
            party: ['party', 'celebration', 'dance'],
            travel: ['travel', 'road trip', 'journey', 'vacation'],
            mood: ['happy', 'sad', 'energetic', 'motivated']
        };
        
        // Pattern matching for common phrases
        if (command.match(/create (?:a |an )?(new )?playlist (called|named|for|titled) (.*)/i)) {
            playlistName = command.match(/create (?:a |an )?(new )?playlist (called|named|for|titled) (.*)/i)[3];
        } 
        else if (command.match(/make (?:a |an )?(new )?playlist (called|named|for|titled) (.*)/i)) {
            playlistName = command.match(/make (?:a |an )?(new )?playlist (called|named|for|titled) (.*)/i)[3];
        }
        else if (command.match(/create (?:a |an )?(new )?(.*) playlist/i)) {
            playlistName = command.match(/create (?:a |an )?(new )?(.*) playlist/i)[2] + " playlist";
        }
        else if (command.match(/make (?:a |an )?(new )?(.*) playlist/i)) {
            playlistName = command.match(/make (?:a |an )?(new )?(.*) playlist/i)[2] + " playlist";
        }
        else {
            // Default case - use the whole command as a name
            playlistName = command.trim();
        }
        
        // Clean up playlist name
        playlistName = playlistName
            .replace(/[.!?]$/, '')  // Remove ending punctuation
            .trim();
            
        // If playlist name is too short, prefix it with "My"
        if (playlistName.length < 3) {
            playlistName = "My Playlist";
        }
        
        // Detect playlist type based on keywords
        const commandLower = command.toLowerCase();
        for (const [type, keywords] of Object.entries(playlistTypes)) {
            if (keywords.some(keyword => commandLower.includes(keyword))) {
                playlistType = type;
                break;
            }
        }
         // Prepare the payload for the recommendations endpoint
         const recommendationPayload = {
            userId: userId.toString(),
            message: command, // Use the voice command as the message
            conversationHistory // Include conversation history for context
        };
        
        console.log('Calling recommendations API with:', recommendationPayload);
        
        // 1. Get recommendations from chatbot endpoint
        const recommendationResponse = await fetch('http://localhost:3000/api/music/recommend/recommendations', {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json',
                'Authorization': req.headers.authorization
            },
            body: JSON.stringify(recommendationPayload)
        });
        
        if (!recommendationResponse.ok) {
            const errorData = await recommendationResponse.text();
            console.error('Recommendation API error:', errorData);
            throw new Error(`Failed to get recommendations: ${recommendationResponse.status} ${recommendationResponse.statusText}`);
        }
        
        // Parse the recommendation response
        const responseData = await recommendationResponse.json();
        console.log('Recommendation API response:', JSON.stringify(responseData, null, 2));
        
        // Extract songs from the response
        let songs = [];
        if (responseData.recommendations) {
            songs = responseData.recommendations;
            console.log('Found songs in recommendations:', songs.length);
        } else if (responseData.songs) {
            songs = responseData.songs;
            console.log('Found songs directly:', songs.length);
        } else {
            console.error('No songs found in API response. Response structure:', Object.keys(responseData));
            throw new Error('No songs found in recommendation response');
        }
        
        if (!Array.isArray(songs) || songs.length === 0) {
            throw new Error('No song recommendations available');
        }
        
        // 2. Create playlist with recommended songs
        const newPlaylist = new Playlist({
            userId: userId,
            name: playlistName,
            type: playlistType,
            songs: songs.map(song => ({
                musicId: song.musicId || song.id || `song-${Date.now()}-${Math.random().toString(36).substring(2, 7)}`,
                title: song.title,
                artist: song.artist,
                spotifyUri: song.spotifyUri || song.uri || song.spotifyUrl,
                albumArt: song.albumArt,
                genre: song.genre || 'Various',
                reason: song.reason || 'Voice recommendation'
            })),
            createdBy: 'voice',
            moodContext: responseData.detectedMood || null
        });
        
        await newPlaylist.save();
        
        
        console.log("Created new playlist from voice command:", newPlaylist);
        
        res.status(201).json({
            message: "Playlist created successfully from voice command",
            playlist: newPlaylist
        });
    } catch (err) {
        console.error("Error creating playlist from voice:", err);
        res.status(500).json({ 
            message: 'Error creating playlist from voice command', 
            error: err.message 
        });
    }
};
</file>

<file path="controllers/userController.js">
import user from '../models/user.js';
export const getUserProfile=async(req,res)=>{
    try{
        const Newuser=await user.findById(req.user.id).select('-password'); //Extracts user ID from the JWT Token (Authentication)
        if(!Newuser){
            res.status(500).json({message:'user not found'});
        }
        res.json(Newuser);
    }catch(err){
        res.status(500).json({message:'Server error',err});
    }
}
export const updatePreferences=async(req,res)=>{
    try{
        const Newuser=await user.findById(req.user.id);// Extracts user ID from the JWT Token (Authentication)
        if(!Newuser){
            res.status(500).json({message:'user not found'});
        }
        Newuser.preferences=req.body.preferences||Newuser.preferences;
        await Newuser.save();
        res.json({message:'user saved successfully',preferences:Newuser.preferences});
    }catch(err){
        res.status(500).json({message:'Server error',err});
    }
}
</file>

<file path="middlewares/authMiddleware.js">
import jwt from 'jsonwebtoken';
import User from '../models/user.js';

const protect = async (req, res, next) => {
  let token;
  
  // First check for JWT in Authorization header
  if (req.headers.authorization && req.headers.authorization.startsWith('Bearer')) {
    console.log('Auth header:', req.headers.authorization);
    try {
      // Get token from header
      token = req.headers.authorization.split(' ')[1];
      
      // Verify token
      const decoded = jwt.verify(token, process.env.JWT_SECRET);
      
      // Set user in request
      req.user = await User.findById(decoded.id).select('-password');
      
      if (!req.user) {
        return res.status(401).json({ message: 'user not found' });
      }
      
      return next();
    } catch (error) {
      console.error("JWT auth error:", error);
      return res.status(401).json({ message: 'Not authorized, token invalid' });
    }
  }
  
  // Fall back to session auth if no JWT
  if (req.session && req.session.user) {
    try {
      const sessionUser = await User.findById(req.session.user._id).select('-password');
      if (!sessionUser) {
        return res.status(401).json({ message: 'user not found' });
      }
      
      req.user = sessionUser;
      return next();
    } catch (error) {
      console.error("Session auth error:", error);
      return res.status(401).json({ message: 'Not authorized' });
    }
  }
  
  // No authentication found
  return res.status(401).json({ message: 'Not authorized, no authentication provided' });
};

export default protect;
</file>

<file path="middlewares/errorHandler.js">
const errorHandler = (err, req, res, next) => {
    console.error("Error:", err.stack);
    res.status(err.statusCode || 500).json({
      success: false,
      message: err.message || "Internal Server Error",
    });
  };
  
  export default errorHandler;
</file>

<file path="middlewares/gamificationMiddleware.js">
//Middleware to test user actions and award points and badges
// const trackAction=(action)=>{
    //     return async(req,res,next)=>{
        //         //Store original res.json and res.send methods
        //         let pointsAwarded = false;
        //         const originalJson=res.json;
        //         const originalSend=res.send;
        
        //         //Run middleware by overriding res.json
        //         res.json=function(data){
            //             //Only award points if original action is successful
            //             if(res.statusCode>=200 && res.statusCode<=300 && req.user?.id){
                //                 //Award points asynchronously
                //                 setImmediate(async ()=>{
                    //                     try{
                        //                         await awardPoints(req.user.id,action,req.socketManager);
                        //                         console.log('sent points request from middleare to service');
                        //                         await checkAndAwardBadges(req.user.id,req.socketManager);
                        //                     }catch(err){
                            //                         console.error('Gamification error:', err);
                            //                     }
                            //                 });
                            //             }
                            //             return originalJson.call(this,data);
                            //         };
                            //         res.send=function(data){
                                //              if (res.statusCode >= 200 && res.statusCode < 300 && req.user?.id) {
                                    //                 setImmediate(async () => {
                                        //                 try {
                                            //                     await awardPoints(req.user.id, action, req.socketManager);
                                            //                     await checkAndAwardBadges(req.user.id, req.socketManager);
                                            //                 } catch (error) {
                                                //                     console.error('Gamification error:', error);
                                                //                 }
                                                //                 });
                                                //             }
                                                //             return originalSend.call(this, data);
                                                //         };
                                                //         next();
                                                //     };
                                                // }
                                                
import { checkAndAwardBadges } from "../services/badgeService.js";
import { awardPoints, updateStreak } from "../services/pointsService.js";
        const trackAction = (action) => {
            return async (req, res, next) => {
        let pointsAwarded = false; // <-- Add this flag
        const originalJson = res.json;
        const originalSend = res.send;

        function awardIfNeeded(data) {
            if (!pointsAwarded && res.statusCode >= 200 && res.statusCode < 300 && req.user?.id) {
                pointsAwarded = true;
                setImmediate(async () => {
                    try {
                        await awardPoints(req.user.id, action, req.socketManager);
                        
                        await checkAndAwardBadges(req.user.id, req.socketManager);

                    } catch (err) {
                        console.error('Gamification error:', err);
                    }
                });
            }
        }

        res.json = function (data) {
            awardIfNeeded(data);
            return originalJson.call(this, data);
        };
        res.send = function (data) {
            awardIfNeeded(data);
            return originalSend.call(this, data);
        };
        next();
    };
};
const trackDailyLogin = async (req, res, next) => {
    console.log('trackDailyLogin middleware running');
    if (req.user?.id) {
        setImmediate(async () => {
            try {
                await awardPoints(req.user.id, 'DAILY_LOGIN', req.socketManager);
                console.log('Daily login points!!');
                await updateStreak(req.user.id, req.socketManager); 
                console.log('Calling Streak Update');
                await checkAndAwardBadges(req.user.id, req.socketManager);
                console.log('Giving badges!!');
            } catch (err) {
                console.error('Daily login tracking error:', err);
            }
        });
    }else{
        console.log('This is not running');
    }
    next();
};
// //Middleware to track daily logins streaks 
// const trackDailyLogin=async(req,res,next)=>{
//     if(req.user?.id){
//         setImmediate(async(req,res)=>{
//             try{
//                 await awardPoints(req.user.id,'DAILY_LOGIN',req.socketManager);
//                 await updateStreak();
//                 console.log('Daily login points!!');
//                 await checkAndAwardBadges(req.user.id,req.socketManager);
//             }catch(err){
//                 console.error('Daily login tracking error:', err);
//             }
//         });
//     }
//     next();
// }
export { trackAction, trackDailyLogin };
</file>

<file path="middlewares/sessionMiddleware.js">
const checkSession=(req,res,next)=>{
    if(req.session.user){
        next();//pass the control to the next middleware or route handler
    }else{
        res.status(401).json({message:'Unauthorized'});
    }
}
export default checkSession;
</file>

<file path="models/Badge.js">
import mongoose from "mongoose";

// Badge Definition Schema
const badgeSchema = new mongoose.Schema({
  name: { type: String, required: true, unique: true },
  description: { type: String, required: true },
  icon: { type: String, required: true }, // URL or icon name
  rarity: { 
    type: String, 
    enum: ['common', 'rare', 'epic', 'legendary'], 
    default: 'common' 
  },
  category: { 
    type: String, 
    enum: ['creation', 'social', 'streak', 'challenge', 'therapy', 'music'], 
    required: true 
  },
  
  // Badge Requirements
  requirement: {
    type: { 
      type: String, 
      required: true 
    }, // 'playlist_count', 'streak_days', 'shares_count', 'therapy_sessions'
    value: { type: Number, required: true },
    description: { type: String } // Human readable requirement
  },
  
  // Badge Properties
  isActive: { type: Boolean, default: true },
  pointsReward: { type: Number, default: 0 }, // Extra points when earned
  color: { type: String, default: '#4F46E5' }, // Badge color theme
  
}, { 
  timestamps: true 
});

// User Badge Ownership Schema
const userBadgeSchema = new mongoose.Schema({
  userId: { 
    type: mongoose.Schema.Types.ObjectId, 
    ref: 'User', 
    required: true 
  },
  badgeId: { 
    type: mongoose.Schema.Types.ObjectId, 
    ref: 'Badge', 
    required: true 
  },
  earnedAt: { type: Date, default: Date.now },
  isDisplayed: { type: Boolean, default: true }, // Whether user shows it on profile
  notificationSent: { type: Boolean, default: false },
  archived:{type : Boolean, default : false}
}, { 
  timestamps: true 
});

// Ensure user can't earn same badge twice
userBadgeSchema.index({ userId: 1, badgeId: 1 }, { unique: true });

// Export both models
export const Badge = mongoose.model("Badge", badgeSchema);
export const UserBadge = mongoose.model("UserBadge", userBadgeSchema);
</file>

<file path="models/Challenge.js">
import mongoose from 'mongoose';

const challengeSchema=new mongoose.Schema({
    title:{
        type:String,
        required:true
    },
    decription:String,
    type:{
        type:String,
        enum:['weekly', 'monthly', 'custom'],
        default:'weekly'
    },
    startDate:{
        type:Date,
        required:true
    },
    endDate: { 
        type: Date, 
        required: true 
    },
    goalType: { 
        type: String, 
        required: true 
    }, // e.g., 'points', 'playlists_created', 'songs_added'
    goalValue: { 
        type: Number, 
        required: true 
    },
    reward: { 
        type: String 
    }, // e.g., 'badge', 'points', 'trophy'
    isActive: { 
        type: Boolean, 
        default: true
    }
},{
    timestamps:true
});
</file>

<file path="models/Gamification.js">
// backend/models/Gamification.js
import mongoose from "mongoose";

const gamificationSchema = new mongoose.Schema({
  userId: { type: mongoose.Schema.Types.ObjectId, ref: 'User', required: true },
  totalPoints: { type: Number, default: 0 },
  level: { type: Number, default: 1 },
  currentStreak: { type: Number, default: 0 },
  longestStreak: { type: Number, default: 0 },
  lastActivity: { type: Date, default: Date.now },
  playlistsShared: { type: Number, default: 0 },
  playlistsCreated:{type: Number, default: 0},
  songsAdded:{type: Number, default: 0},
  dailyLogins: { type: Number, default: 0 },
  badges: [{ type: mongoose.Schema.Types.ObjectId, ref: 'Badge' }]
}, { timestamps: true });

export default mongoose.model('Gamification', gamificationSchema);
</file>

<file path="models/Leaderboard.js">
import mongoose from "mongoose";

const leaderboardEntrySchema = new mongoose.Schema({
  userId: { type: mongoose.Schema.Types.ObjectId, ref: 'User', required: true },
  username: { type: String, required: true },
  totalPoints: { type: Number, required: true },
  level: { type: Number, required: true },
  currentStreak: { type: Number, default: 0 },
  badgeCount: { type: Number, default: 0 }
}, { _id: false });

const leaderboardSchema = new mongoose.Schema({
  type: { type: String, enum: ['alltime', 'weekly', 'monthly'], required: true },
  period: { type: String, required: true }, // e.g. "2025-W24" for weekly, "2025-06" for monthly
  entries: [leaderboardEntrySchema],
  lastUpdated: { type: Date, default: Date.now }
}, { timestamps: true });

leaderboardSchema.index({ type: 1, period: 1 }, { unique: true });

export default mongoose.model('Leaderboard', leaderboardSchema);
</file>

<file path="models/MusicResource.js">
import mongoose from "mongoose";

const musicResourceSchema = new mongoose.Schema({
  title: { type: String, required: true },
  artist: { type: String, required: true },
  genre: { type: String, required: true },
  moodTags: { type: [String], default: [] }, // ["calm", "focus", "relaxing"]
  audioUrl: { type: String, required: true }, // URL to music file or Spotify URL
  duration: { type: Number, required: true }, // Duration in seconds
  recommendedFor: { type: [String], default: [] }, // ["meditation", "sleep", "study"]
  
  // Spotify-specific fields
  spotifyId: { type: String },
  spotifyUri: { type: String },
  spotifyUrl: { type: String },
  previewUrl: { type: String }, // 30-second preview URL
  albumArt: { type: String }, // Album cover image URL
  popularity: { type: Number }, // Spotify popularity score (0-100)
  explicit: { type: Boolean, default: false },

  //NEW
  // Add Spotify audio features
  audioFeatures: {
    danceability: Number,
    energy: Number,
    valence: Number, // Positivity/happiness measure
    tempo: Number,
    acousticness: Number,
    instrumentalness: Number,
    liveness: Number,
    speechiness: Number
  },
  
  // Add cultural context tags
  culturalTags: [String],
  
  // Add recommendation metadata
  recommendationScore: Number,
  lastRecommendedAt: Date
  //NEW
});

// Compound index to avoid duplicates
musicResourceSchema.index({ title: 1, artist: 1 }, { unique: true });

export default mongoose.model("MusicResource", musicResourceSchema);
</file>

<file path="models/Playlist.js">
import crypto from 'crypto';
import mongoose from 'mongoose';
const playlistSchema = new mongoose.Schema({
    userId: {
        type: mongoose.Schema.Types.ObjectId,
        ref: 'User',
        required: true
    },
    name: {
        type: String,
        required: true
    },
    collaborators:[{
        type:mongoose.Schema.Types.ObjectId,
        ref:'User'
    }],
    inviteLink:{
        code:{
            type:String,
            default:()=> crypto.randomBytes(6).toString('hex')
        },
        expiresAt:{
            type:Date,
            default:()=> new Date(Date.now() + 7*24*60*60*1000)//7 days
        }
    },
    
    
    songs: [{
        musicId: {
            type: mongoose.Schema.Types.ObjectId,
            ref: 'MusicResource'
        },
        title: String,
        artist: String,
        audioUrl: String,
        spotifyUri:String ,
        albumArt:String ,
        genre: String,
        reason: String
    }]
}, { timestamps: true });

const Playlist = mongoose.model('Playlist', playlistSchema);
export default Playlist;
</file>

<file path="models/Recommendation.js">
import mongoose from "mongoose";

const recommendationSchema = new mongoose.Schema({
  userId: { type: mongoose.Schema.Types.ObjectId, ref: "User", required: true },
  recommendedMusic: [
    {
      musicId: { type: mongoose.Schema.Types.ObjectId, ref: "MusicResource" },
      reason: { type: String }, // Why this music was recommended
    },
  ],
  generatedAt: { type: Date, default: Date.now },
});

export default mongoose.model("Recommendation", recommendationSchema);
</file>

<file path="models/TherapySession.js">
import mongoose from "mongoose";

const therapySessionSchema = new mongoose.Schema({
  userId: { type: mongoose.Schema.Types.ObjectId, ref: "User", required: true },
  sessionType: { type: String, required: true }, // "meditation", "focus", "sleep therapy"
  musicUsed: { type: mongoose.Schema.Types.ObjectId, ref: "MusicResource" },
  sessionDuration: { type: Number, required: true }, // Duration in minutes
  feedback: {
    rating: { type: Number, min: 1, max: 5 },
    comment: { type: String },
  },
  date: { type: Date, default: Date.now },
});

export default mongoose.model("TherapySession", therapySessionSchema);
</file>

<file path="models/user.js">
import mongoose from "mongoose";

const userSchema = new mongoose.Schema({
  // name: { type: String, required: true },
  // email: { type: String, required: true, unique: true },
  // password: { type: String, required: true },

  _id: { type: mongoose.Schema.Types.ObjectId, auto: true },
  name: { type: String, required: true },
  email: { type: String, required: true, unique: true },
  password: { type: String, required: true },

  // Preferences & Personalization
  preferences: { type: [String], default: [] }, // ["calm music", "nature sounds"]
  favoriteTracks: { type: [mongoose.Schema.Types.ObjectId], ref: "MusicResource" },

  // Therapy & Session Tracking
  moodTracking: [
    {
      mood: { type: String },
      date: { type: Date, default: Date.now },
      
    },
  ],
  sessionHistory: [
    {
      sessionType: { type: String }, // "meditation", "sleep therapy"
      sessionDate: { type: Date, default: Date.now },
    },
  ],
  lastSessionDate: { type: Date },
  feedbackHistory: [
    {
      sessionId: { type: mongoose.Schema.Types.ObjectId, ref: "TherapySession" },
      rating: { type: Number, min: 1, max: 5 },
      comment: { type: String },
    },
  ],
  // Add music behavior tracking
  musicBehavior: {
    likes: [{ 
      songId: { type: mongoose.Schema.Types.ObjectId, ref: "MusicResource" },
      timestamp: { type: Date, default: Date.now }
    }],
    skips: [{ 
      songId: { type: mongoose.Schema.Types.ObjectId, ref: "MusicResource" },
      timestamp: { type: Date, default: Date.now }
    }],
    playlistAdditions: [{
      songId: { type: mongoose.Schema.Types.ObjectId, ref: "MusicResource" },
      playlistId: { type: mongoose.Schema.Types.ObjectId, ref: "Playlist" },
      context: String, // "workout", "study", etc.
      timestamp: { type: Date, default: Date.now }
    }]
  },

  
});

// Add indexes for points and analytics
userSchema.index({ 'points.total': -1 });
userSchema.index({ level: -1 });
userSchema.index({ reputation: -1 });

export default mongoose.model("User", userSchema);
</file>

<file path="routes/authRoutes.js">
import express from 'express';
import { body } from 'express-validator'; //validate request body data
import { checkAuth, login, register } from '../controllers/authController.js';
import { trackDailyLogin } from '../middlewares/gamificationMiddleware.js';
const router = express.Router();

// Register route
router.post('/register', [
    body('name').not().isEmpty().withMessage('Name is required'),
    body('email').isEmail().withMessage('Enter valid email'),
    body('password').isLength({ min: 6 }).withMessage('Password should be of length 6 or more'),
], register);

// Login route
router.post('/login', [
    body('email').isEmail().withMessage('Enter valid email'),
    body('password').not().isEmpty().withMessage('Password is required')
],login, trackDailyLogin );

// Check session route
router.get('/check-session', checkAuth,trackDailyLogin);

export default router;
</file>

<file path="routes/gamificationRoutes.js">
import express from 'express';
import { awardPointsController, getUserStats } from '../controllers/gamificationController.js';
import protect from '../middlewares/authMiddleware.js';
const router=express.Router();

router.get('/stats/:userId',protect,getUserStats);
router.post('award-points',protect,awardPointsController);
export default router;
</file>

<file path="routes/geminiRoutes.js">
import express from 'express';
import { analyzeMood, chatWithAI } from '../controllers/geminiController.js';

const router = express.Router();

router.post('/analyze-mood', analyzeMood);
router.post('/chat', chatWithAI);

export default router;
</file>

<file path="routes/leaderboardRoutes.js">
import express from 'express';
import { fetchLeaderBoard } from '../controllers/leaderboardController.js';
const router=express.Router();

router.get('/',fetchLeaderBoard);
export default router;
</file>

<file path="routes/moodRoutes.js">
import express from 'express';
import { analyzeMood } from '../controllers/moodController.js';
const router=express.Router();
router.post('/analyze-mood',analyzeMood);
export default router;
</file>

<file path="routes/musicRoutes.js">
// import express from 'express';
// import { getMusicRecommendations, getSpotifyEmbed } from '../controllers/musicController.js';
// const router=express.Router();
// router.post('/',getMusicRecommendations);
// router.get('/spotify/embed/:trackId', getSpotifyEmbed);
// export default router;

import express from 'express';
import {
    getMusicRecommendations,
    getSpotifyAuthUrl,
    getSpotifyEmbed,
    handleSpotifyCallback
} from '../controllers/musicController.js';

const router = express.Router();

// Music recommendation routes
router.post('/recommendations', getMusicRecommendations);
router.get('/spotify/embed/:trackId', getSpotifyEmbed);
router.get('/spotify/auth',getSpotifyAuthUrl);
router.get('/spotify/callback',handleSpotifyCallback);
export default router;
</file>

<file path="routes/playlistRoutes.js">
import express from 'express';
import { acceptInvitation, addSongToPlaylist, createPlaylist, createPlaylistFromVoice, deletePlaylist, generateInviteLink, generateInviteQR, getCollaborators, getUserPlaylists, inviteByUsername, removeCollaborator, removeSongFromPlaylist } from '../controllers/playlistController.js';
import protect from '../middlewares/authMiddleware.js';
import { trackAction } from '../middlewares/gamificationMiddleware.js';
const router = express.Router();

// Apply auth middleware to all routes
router.use(protect);

router.post('/create',trackAction('PLAYLIST_CREATED'),createPlaylist);
router.post('/addsong',trackAction('SONG_ADDED'),addSongToPlaylist);
router.post('/removesong',removeSongFromPlaylist);
router.delete('/delete/:playlistId', deletePlaylist);
// router.get('/:userId', getUserPlaylists);
// New route for voice playlist creation
router.post('/create-from-voice',trackAction('PLAYLIST_CREATED'), createPlaylistFromVoice);
router.get('/my-playlists', getUserPlaylists); // Changed from '/:userId' to '/my-playlists'
//Collaboration routes
router.post('/invite/username',trackAction('PLAYLIST_SHARED'),inviteByUsername);
router.post('/invite/link/:playlistId', trackAction('PLAYLIST_SHARED'),generateInviteLink);
router.post('/invite/qr/:playlistId',trackAction('PLAYLIST_SHARED'),generateInviteQR);
router.get('/invite/accept/:inviteCode', acceptInvitation);
router.get('/:playlistId/collaborators', getCollaborators);
router.delete('/:playlistId/collaborators/:userId', removeCollaborator);
export default router;
</file>

<file path="routes/userRoutes.js">
import express from 'express';
import { analyzeMood } from '../controllers/moodController.js';
import { getUserProfile, updatePreferences } from '../controllers/userController.js';
import protect from '../middlewares/authMiddleware.js';
const router=express.Router();
router.get('/profile',protect,getUserProfile);
router.put('/preferences',protect,updatePreferences);
router.post('/analyze-mood',analyzeMood);
export default router;
</file>

<file path="services/badgeService.js">
import { Badge, UserBadge } from '../models/Badge.js';
import Gamification from '../models/Gamification.js';
import Playlist from '../models/Playlist.js';

 //Check badge requirements
export const checkBadgeRequirement=async(userId,badge,userGamification)=>{
    const {type,value}=badge.requirement;
    switch(type){
        case 'playlist_count' :
            const playlistCount = await Playlist.countDocuments({userId});
            return playlistCount>=value;
        case 'streak_days':
            return userGamification.currentStreak>=value;
        case 'playlists_shared':
            return userGamification.playlistsShared >= value;
        case 'daily_logins':
            return userGamification.dailyLogins >= value;
        default: 
            console.warn(`Unknown badge requirement type : ${type}`);
            return false;
    }
}
export const awardBadge=async(userId,badgeId,socketManager)=>{
    try{
        const existingUserBadge=await UserBadge.findOne({userId,badgeId});
        if(existingUserBadge){
            return false;//user already has this badge 
        }
        //Create new userBadge record
        const userBadge=new UserBadge({
            userId,
            badgeId
        });
        await userBadge.save();
        //Update user's gamification
        const userGamification=await Gamification.findOne({userId});
        if(userGamification){
            userGamification.badges.push(badgeId);
            await userGamification.save();
        }
        //Get badge details
        const badge=await Badge.findById(badgeId);
        //Real time notification
        if(socketManager && socketManager.emitToUser){
            socketManager.emitToUser(userId,'badge_earned',{
                badge:{
                    id: badge._id,
                    name: badge.name,
                    description: badge.description,
                    rarity: badge.rarity,
                    icon: badge.icon,
                    category: badge.category
                },
                earnedAt:userBadge.earnedAt
            });
        }
        console.log(`Badge "${badge.name}" awarded to user ${userId}`);
        return true;
    }catch(err){
        console.error('Error awarding badge:', err);
        throw err;
    }
}
export const checkAndAwardBadges=async(userId,socketManager)=>{
    try{
        const userGamification=await Gamification.findOne({userId});
        if(!userGamification){
            console.log(`No gamification record found for user ${userId}`);
            return 0;
        }
        //Get all active badges
        const allBadges=await Badge.find({isActive : true});
        //Get badges user already has
        const userBadges=await UserBadge.find({userId});
        const earnedBadgeIds=userBadges.map(ub=> ub.badgeId.toString());
        let newBadgesAwarded=0;
        for(const badge of allBadges){
            //Skip if user already has this badge
            if(earnedBadgeIds.includes(badge._id.toString())){
                continue;
            }
            //Check if user meets requirements
            const meetsRequirement=await checkBadgeRequirement(userId,badge,userGamification);
            if(meetsRequirement){
                const awarded=await awardBadge(userId,badge._id,socketManager);
                if(awarded){
                    newBadgesAwarded++;
                }
            }
        }
        return newBadgesAwarded;
    }catch(err){
        console.error('Error checking badges:', err);
        throw err;
    }
}
//Get user badges
export const getUserBadges=async(userId)=>{
    try{
        const userBadges=await UserBadge.find({userId}).populate('badgeId').sort({earnedAt : -1});
        return userBadges.map(userBadge => ({
            ...userBadge.badgeId.toObject(),
            earnedAt: userBadge.earnedAt,
            isDisplayed: userBadge.isDisplayed
        }));
    }catch(err){
        console.error('Error getting user badges:', err);
        throw err;
    }
}
//Initialize default badges in the db
export const initializeDefaultBadges=async()=>{
    try{
        const {BADGES} =await import ('../config/gamification.js');
        for(const badgeData of BADGES){
            const existingBadge=await Badge.findOne({name: badgeData.name});
            if(!existingBadge){
                const badge=new Badge({
                    ...badgeData,
                    icon: badgeData.icon || '/icons/badge-default.svg',
                    pointsReward: badgeData.pointsReward || 0,
                    isActive: true
                });
                await badge.save();
                console.log(`Created badge: ${badge.name}`);
            }
        }
    }catch(err){
        console.error('Error initializing badges:', err);
    }
}
</file>

<file path="services/leaderboardService.js">
import Gamification from "../models/Gamification.js";
import LeaderBoard from "../models/LeaderBoard.js";

export const updateLeaderboard=async(type='alltime',period='all')=>{
    //Fetch all users anf their gamification stats
    const gamifications=await Gamification.find().populate('userId');
    //SORT--> descending , then be level then by streak
    const sorted=gamifications.sort((a,b)=> b.totalPoints-a.totalPoints || b.level - a.level || b.currentStreak - a.currentStreak).slice(0,100);//Top 100
     const entries = sorted.map((g,idx)=> ({
        userId: g.userId._id,
        username: g.userId.name,
        totalPoints: g.totalPoints,
        level: g.level,
        currentStreak: g.currentStreak,
        badgeCount: Array.isArray(g.badges) ? g.badges.length : 0,
        rank: idx + 1
     }));
     //Upsert leaderboard
     await LeaderBoard.findOneAndUpdate({type,period},{entries,lastUpdated:new Date()},{upsert: true,new : true});
}
export const getLeaderboard=async(type='alltime',period='all')=>{
    const leaderboard=await LeaderBoard.findOne({type,period});
    return leaderboard ? leaderboard.entries : [];
}
</file>

<file path="services/pointsService.js">
import { LEVELS, POINTS } from '../config/gamification.js';
import Gamification from "../models/Gamification.js";
import { updateLeaderboard } from './leaderboardService.js';
export const calculateLevel=(totalPoints)=>{
    let level=1;
    for(const levelData of LEVELS){
        if(totalPoints >= levelData.minPoints){
            level=levelData.level;
        }
    }
    return level;
}
export const awardPoints=async(userId,action,socketManager,metadata={})=>{
    console.log(`awardPoints called for user ${userId} and action ${action}`);
    try{
        const points=POINTS[action.toUpperCase()] || 0;
        let userGamification=await Gamification.findOne({userId});
        if(!userGamification){
            userGamification=new Gamification({userId});
        }
        //Add points 
        userGamification.totalPoints+=points;
        console.log('5 points for login');
        //Check level up
        const newLevel=calculateLevel(userGamification.totalPoints);
        const leveledUp=newLevel > userGamification.level;
        userGamification.level=newLevel;
        //Update tracking counters based on action
        switch(action.toUpperCase()){
            case 'PLAYLIST_SHARED':
                userGamification.playlistsShared = (userGamification.playlistsShared || 0) + 1;
                break;
            case 'DAILY_LOGIN':
                userGamification.dailyLogins = (userGamification.dailyLogins || 0) + 1;
                break;
            case 'PLAYLIST_CREATED':
                userGamification.playlistsCreated = (userGamification.playlistsCreated || 0) + 1;
                break;
            case 'SONG_ADDED':
                userGamification.songsAdded = (userGamification.songsAdded || 0) + 1;
                break;
        }

        //Update last activity for streak tracking
        // userGamification.lastActivity=new Date();
        await userGamification.save();
        //Real time update via websockets
        if(socketManager && socketManager.emitToUser){
            console.log('Emitting points_awarded for', userId);
            socketManager.emitToUser(userId,'points_awarded',{
                points,
                action,
                totalPoints: userGamification.totalPoints,
                level: userGamification.level,
                leveledUp
            })
        }

        if (leveledUp) {
        console.log('Emitting level_up for', userId);
        socketManager.emitToUser(userId, 'level_up', {
            
            level: userGamification.level,
            totalPoints: userGamification.totalPoints
        });
        }
        await updateLeaderboard('alltime','all');
        return {points,totalPoints:userGamification.totalPoints,leveledUp};
    }catch(err){
        console.error('Error awarding points:', err);
        throw err;
    }
}
//Update user streak based on daily activity
export const updateStreak=async(userId,socketManager)=>{
    console.log(`updateStreak called for user ${userId}`);
    try{
        let userGamification=await Gamification.findOne({userId});
        if(!userGamification){
            userGamification=new Gamification({userId});
        }
        const now=new Date();
        const lastActivity=new Date(userGamification.lastActivity);
        const timeDiff=now.getTime()-lastActivity.getTime();
        const daysDiff=Math.floor(timeDiff / (1000*3600*24));
        if(!lastActivity || userGamification.currentStreak===0){
            //First ever login or streak is reset
            userGamification.currentStreak=1;
            userGamification.longestStreak=Math.max(userGamification.longestStreak || 0,1);
        }else if(daysDiff===1){
            //consecutive day--> increment the streak
            userGamification.currentStreak+=1;
            if(userGamification.currentStreak>userGamification.longestStreak){
                userGamification.longestStreak=userGamification.currentStreak;
            }
        }else if(daysDiff > 1){
            //Streak is broken
            userGamification.currentStreak=1;
        }
        //daysDiff==0 ==> no change as it is the same day
        userGamification.lastActivity=now;
        await userGamification.save();
        //Emit streak update
        if(socketManager && socketManager.emitToUser){
            console.log('Emitting streak_updated for', userId);
            socketManager.emitToUser(userId,'streak_updated',{
                currentStreak:userGamification.currentStreak,
                longestStreak:userGamification.longestStreak
            });
        }
        return userGamification.currentStreak;
    }catch(err){
        console.error('Error updating streak:', err);
        throw err;
    }
}
</file>

<file path="services/socketManager.js">
class SocketManager{
    constructor(io){
        this.io=io;
        this.rooms=new Map();//Map to track users in each playlist room
        this.initialize();
    }
    initialize(){
            this.io.on('connection',(socket)=>{
                console.log('A user connected:',socket.id);
    
            //handle joining a playlist room
            socket.on('join_playlist',(data)=>{
                const {playlistId,userId,username}=data;
                this.handleJoinPlaylist(socket,playlistId,userId,username);
            });
            socket.on('register_user', (data) => {
                const { userId } = data;
                if (userId) {
                    socket.join(`user:${userId}`);
                    console.log(`Socket ${socket.id} joined user room user:${userId}`);
                }
            });

            //Handle leaving a playlist room
            socket.on('leave_playlist',(data)=>{
                const {playlistId,userId}=data;
                this.handleLeavePlaylist(socket,playlistId,userId);
            });
            //handle adding a song to playlist
            socket.on('add_song',(data)=>{
                const {playlistId,song,userId,username}=data;
                this.handleAddSong(socket,playlistId,song,userId,username);
            });
            //handle removing a song from playlist
            socket.on('remove_song',(data)=>{
                const {playlistId,songId,userId,username}=data;
                this.handleRemoveSong(socket,playlistId,songId,userId,username);
            });
            //handle reordering songs
            socket.on('reorder_songs',(data)=>{
                const { playlistId, newOrder, userId, username } = data;
                this.handleReorderSongs(socket, playlistId, newOrder, userId, username);
            });
            //Handle collaborator added event
            socket.on('collaborator_added',(data)=>{
                const {playlistId,userId,username,collaboratorId,collaboratorName}=data;
                this.handleCollaboratorAdded(socket,playlistId,userId,username,collaboratorId,collaboratorName);
            })
            //Handle accepting invite
            socket.on('invitation_accepted',(data)=>{
                const { playlistId, userId, username } = data;
                this.handleInvitationAccepted(socket, playlistId, userId, username);
            })
            //Handle removing a collaborator
            socket.on('collaborator_removed',(data)=>{
                const {playlistId, userId, username, removedCollaboratorId, removedCollaboratorName}=data;
                this.handleCollaboratorRemoved(socket, playlistId, userId, username, removedCollaboratorId, removedCollaboratorName);
            })
            //Handle playlist updated
            socket.on('playlist_updated',(data)=>{
                const { playlistId, userId, username } = data;
                this.handlePlaylistUpdated(socket, playlistId, userId, username);
            });
            
            //Handle disconnection
            socket.on('disconnect',()=>{
                this.handleDisconnect(socket);
            });

        });
    }

    handlePlaylistUpdated(socket,playlistId,userId,username){
        const roomId=`playlist:${playlistId}`;
            //Add user to the room tracking
            if(!this.rooms.has(roomId)){
                this.rooms.set(roomId,new Map());
            }
            this.rooms.get(roomId).set(userId,{
                socketId:socket._id,
                username
            });
            //Get all users in the room
            const usersInRoom=Array.from(this.rooms.get(roomId).entries()).map(([id,data])=>({
                userId:id,
                username:data.username
            }));

            //Broadcast to everyone in the room that someone has joined
            this.io.to(roomId).emit('playlist_updated',{
                userId,
                username,
                users: usersInRoom,
            });
    }
    emitToUser(userId, event, data) {
        const userRoom = `user:${userId}`;
        this.io.to(userRoom).emit(event, data);
        console.log(`Emitted ${event} to user ${userId}:`, data);
    }


    handleCollaboratorRemoved(socket, playlistId, userId, username, removedCollaboratorId, removedCollaboratorName){
        const roomId=`playlist:${playlistId}`;
        //Broadcast to everyone in the room that a collaborator was removed
        this.io.to(roomId).emit('collaborator_removed',{
            playlistId,
            removedCollaborator: {
                userId: removedCollaboratorId,
                username: removedCollaboratorName
            },
            removedBy: {
                userId,
                username
            }
        });

        console.log(`User ${username} (${userId}) removed ${removedCollaboratorName} as collaborator from playlist ${playlistId}`);
    }


    handleCollaboratorAdded(socket, playlistId, userId, username, collaboratorId, collaboratorName){
        const roomId=`playlist:${playlistId}`;
        //Broadcast to everyone in the room that a collaborator was added
        this.io.to(roomId).emit('collaborator_added',{
            playlistId,
            collaborator: {
                userId: collaboratorId,
                username: collaboratorName
            },
            addedBy: {
                userId,
                username
            }
        });
        console.log(`User ${username} (${userId}) added ${collaboratorName} as collaborator to playlist ${playlistId}`);
    }
    
    handleJoinPlaylist(socket,playlistId,userId,username){
        const roomId=`playlist:${playlistId}`;

        //Joing the socket to the room
        socket.join(roomId);
        //Store the user data in socket for easy access
        socket.userData={
            currentRoom: roomId,
            userId,
            username
        };
        //Track users in the room
        if(!this.rooms.has(roomId)){
            this.rooms.set(roomId,new Map());
        }
        this.rooms.get(roomId).set(userId,{
            socketId:socket.id,
            username
        });

        //Get all users in the room
        const usersInRoom=Array.from(this.rooms.get(roomId).entries()).map(([id,data])=>({
            userId:id,
            username:data.username
        }));
        //Broadcast to everyone in the room that someone has joined the room
        this.io.to(roomId).emit('user_joined',{
            userId,
            username,
            users:usersInRoom
        });
        console.log(`User ${username} (${userId}) joined playlist ${playlistId}`);
    }


        handleLeavePlaylist(socket,playlistId,userId){
            const roomId=`playlist:${playlistId}`;
            //Remove user from the room tracking
            if(this.rooms.has(roomId)){
                const username=this.rooms.get(roomId).get(userId)?.username;
                this.rooms.get(roomId).delete(userId);

                //If room is empty, remove it
                if(this.rooms.get(roomId).size===0){
                    this.rooms.delete(roomId);
                }else{
                    //Get remaining users
                    const usersInRoom=Array.from(this.rooms.get(roomId).entries()).map(([id,data])=>({
                        userId:id,
                        username:data.username
                    }));
                
                    //Notify others that user left
                    this.io.to(roomId).emit('user_left',{
                        userId,
                        username,
                        users:usersInRoom
                    })
                }
            }
            //Leave the socket room
            socket.leave(roomId);
            socket.userData=null;
            console.log(`User ${userId} left playlist ${playlistId}`);
        }

        handleDisconnect(socket){
            console.log('User disconnected: ',socket.id);
            //If user was in a playlist room, handle leaving
            if(socket.userData){
                const {currentRoom,userId,username}=socket.userData;
                const playlistId=currentRoom.split(':')[1];
                if(this.rooms.has(currentRoom)){
                    this.rooms.get(currentRoom).delete(userId);

                    //If room get empty --> remove it
                    if(this.rooms.get(currentRoom).size===0){
                        this.rooms.delete(currentRoom);
                    }else{
                        //get remaining users
                        const usersInRoom=Array.from(this.rooms.get(currentRoom).entries()).map(([id,data])=>({
                            userId:id,
                            username:data.username
                        }));

                        //notify them that user has left
                        this.io.to(currentRoom).emit('user_left',{
                            userId,
                            username,
                            users:usersInRoom
                        });
                    }
                }
            }
        }
        
        handleAddSong(socket, playlistId, song, userId, username){
            const roomId=`playlist:${playlistId}`;
            //broadcast to everyone that song has been added
            this.io.to(roomId).emit('song_added',{
                playlistId,
                song,
                addedBy: {
                    userId,
                    username
                }
            })
            console.log(`User ${username} (${userId}) added a song to playlist ${playlistId}`);
        }

        handleRemoveSong(socket, playlistId, songId, userId, username){
            const roomId=`playlist:${playlistId}`;
            //broadcast to everyone that song has been removed
            this.io.to(roomId).emit('song_removed',{
                playlistId,
                songId,
                removedBy: {
                    userId,
                    username
                }
            });
            console.log(`User ${username} (${userId}) removed a song from playlist ${playlistId}`);
        }
        handleReorderSongs(socket, playlistId, newOrder, userId, username){
            const roomId=`playlist:${playlistId}`;
            //broadcast to everyone that song has been removed
            this.io.to(roomId).emit('songs_reordered',{
                playlistId,
                newOrder,
                reorderedBy: {
                    userId,
                    username
                }
            });
            console.log(`User ${username} (${userId}) reordered songs in playlist ${playlistId}`);
        }

        handleInvitationAccepted(socket,playlistId,userId,username){
            const roomId=`playlist:${playlistId}`;
            //Add user to the room tracking
            if(!this.rooms.has(roomId)){
                this.rooms.set(roomId,new Map());
            }
            this.rooms.get(roomId).set(userId,{
                socketId:socket._id,
                username
            });
            //Get all users in the room
            const usersInRoom=Array.from(this.rooms.get(roomId).entries()).map(([id,data])=>({
                userId:id,
                username:data.username
            }));

            //Broadcast to everyone in the room that someone has joined
            this.io.to(roomId).emit('user_joined',{
                userId,
                username,
                users: usersInRoom,
                joinedVia: 'invitation'
            });
            console.log(`User ${username} (${userId}) accepted invitation to playlist ${playlistId}`);
        }
}
export default SocketManager;
</file>

<file path="utils/passwordUtils.js">
import bcrypt from 'bcryptjs';
export const hashPassword=async(password)=>{
    return await bcrypt.hash(password,10);
}
export const matchPassword=async(enteredPassword,hashedPassword)=>{
    return await bcrypt.compare(enteredPassword,hashedPassword);
}
</file>

<file path="package-lock 2.json">
{
  "name": "music-therapy",
  "version": "1.0.0",
  "lockfileVersion": 3,
  "requires": true,
  "packages": {
    "": {
      "name": "music-therapy",
      "version": "1.0.0",
      "license": "ISC",
      "dependencies": {
        "@clerk/clerk-sdk-node": "^4.13.23",
        "@huggingface/inference": "^3.6.2",
        "bcryptjs": "^3.0.2",
        "cors": "^2.8.5",
        "dotenv": "^16.4.7",
        "express": "^4.21.2",
        "express-async-errors": "^3.1.1",
        "express-validator": "^7.2.1",
        "jsonwebtoken": "^9.0.2",
        "mongoose": "^8.13.0",
        "nodemon": "^3.1.9"
      }
    },
    "node_modules/@clerk/backend": {
      "version": "0.38.15",
      "resolved": "https://registry.npmjs.org/@clerk/backend/-/backend-0.38.15.tgz",
      "integrity": "sha512-zmd0jPyb1iALlmyzyRbgujQXrGqw8sf+VpFjm5GkndpBeq5+9+oH7QgMaFEmWi9oxvTd2sZ+EN+QT4+OXPUnGA==",
      "license": "MIT",
      "dependencies": {
        "@clerk/shared": "1.4.2",
        "@clerk/types": "3.65.5",
        "@peculiar/webcrypto": "1.4.1",
        "@types/node": "16.18.6",
        "cookie": "0.5.0",
        "deepmerge": "4.2.2",
        "node-fetch-native": "1.0.1",
        "snakecase-keys": "5.4.4",
        "tslib": "2.4.1"
      },
      "engines": {
        "node": ">=14"
      }
    },
    "node_modules/@clerk/backend/node_modules/cookie": {
      "version": "0.5.0",
      "resolved": "https://registry.npmjs.org/cookie/-/cookie-0.5.0.tgz",
      "integrity": "sha512-YZ3GUyn/o8gfKJlnlX7g7xq4gyO6OSuhGPKaaGssGB2qgDUS0gPgtTvoyZLTt9Ab6dC4hfc9dV5arkvc/OCmrw==",
      "license": "MIT",
      "engines": {
        "node": ">= 0.6"
      }
    },
    "node_modules/@clerk/backend/node_modules/snakecase-keys": {
      "version": "5.4.4",
      "resolved": "https://registry.npmjs.org/snakecase-keys/-/snakecase-keys-5.4.4.tgz",
      "integrity": "sha512-YTywJG93yxwHLgrYLZjlC75moVEX04LZM4FHfihjHe1FCXm+QaLOFfSf535aXOAd0ArVQMWUAe8ZPm4VtWyXaA==",
      "license": "MIT",
      "dependencies": {
        "map-obj": "^4.1.0",
        "snake-case": "^3.0.4",
        "type-fest": "^2.5.2"
      },
      "engines": {
        "node": ">=12"
      }
    },
    "node_modules/@clerk/clerk-sdk-node": {
      "version": "4.13.23",
      "resolved": "https://registry.npmjs.org/@clerk/clerk-sdk-node/-/clerk-sdk-node-4.13.23.tgz",
      "integrity": "sha512-D3/O5zLqOtIcoNjA5tza1WK+o3Bs20DcmFc2z8swv7p8p5i5fj5Q1rEZl31bnz+fEQGo2YtTYZyG0zY/HkioQw==",
      "license": "MIT",
      "dependencies": {
        "@clerk/backend": "0.38.15",
        "@clerk/shared": "1.4.2",
        "@clerk/types": "3.65.5",
        "@types/cookies": "0.7.7",
        "@types/express": "4.17.14",
        "@types/node-fetch": "2.6.2",
        "camelcase-keys": "6.2.2",
        "snakecase-keys": "3.2.1",
        "tslib": "2.4.1"
      },
      "engines": {
        "node": ">=14"
      }
    },
    "node_modules/@clerk/shared": {
      "version": "1.4.2",
      "resolved": "https://registry.npmjs.org/@clerk/shared/-/shared-1.4.2.tgz",
      "integrity": "sha512-R+OkzCtnNU7sn/F6dBfdY5lKs84TN785VZdBBefmyr7zsXcFEqbCcfQzyvgtIS28Ln5SifFEBoAyYR334IXO8w==",
      "license": "MIT",
      "dependencies": {
        "glob-to-regexp": "0.4.1",
        "js-cookie": "3.0.1",
        "swr": "2.2.0"
      },
      "peerDependencies": {
        "react": ">=16"
      },
      "peerDependenciesMeta": {
        "react": {
          "optional": true
        }
      }
    },
    "node_modules/@clerk/types": {
      "version": "3.65.5",
      "resolved": "https://registry.npmjs.org/@clerk/types/-/types-3.65.5.tgz",
      "integrity": "sha512-RGO8v2a52Ybo1jwVj42UWT8VKyxAk/qOxrkA3VNIYBNEajPSmZNa9r9MTgqSgZRyz1XTlQHdVb7UK7q78yAGfA==",
      "license": "MIT",
      "dependencies": {
        "csstype": "3.1.1"
      },
      "engines": {
        "node": ">=14"
      }
    },
    "node_modules/@huggingface/inference": {
      "version": "3.6.2",
      "resolved": "https://registry.npmjs.org/@huggingface/inference/-/inference-3.6.2.tgz",
      "integrity": "sha512-FkJr8dOP8yFTxGFi+X/ylwG3qoCq/s8WI2A4Jg13RBX3voJWrzadpHLD/99EKZU7r35X4Mm6tKUev7dR2B/cTg==",
      "license": "MIT",
      "dependencies": {
        "@huggingface/jinja": "^0.3.3",
        "@huggingface/tasks": "^0.18.4"
      },
      "engines": {
        "node": ">=18"
      }
    },
    "node_modules/@huggingface/jinja": {
      "version": "0.3.3",
      "resolved": "https://registry.npmjs.org/@huggingface/jinja/-/jinja-0.3.3.tgz",
      "integrity": "sha512-vQQr2JyWvVFba3Lj9es4q9vCl1sAc74fdgnEMoX8qHrXtswap9ge9uO3ONDzQB0cQ0PUyaKY2N6HaVbTBvSXvw==",
      "license": "MIT",
      "engines": {
        "node": ">=18"
      }
    },
    "node_modules/@huggingface/tasks": {
      "version": "0.18.4",
      "resolved": "https://registry.npmjs.org/@huggingface/tasks/-/tasks-0.18.4.tgz",
      "integrity": "sha512-kZ8G2b6JSdVCn48VpmB2Kcb9ae16HmDRf4RWEQJMgbF98DFTt4y69fTcvQ1vi/qALRWL57pDpbzIlwWlVhY3aQ==",
      "license": "MIT"
    },
    "node_modules/@mongodb-js/saslprep": {
      "version": "1.2.0",
      "resolved": "https://registry.npmjs.org/@mongodb-js/saslprep/-/saslprep-1.2.0.tgz",
      "integrity": "sha512-+ywrb0AqkfaYuhHs6LxKWgqbh3I72EpEgESCw37o+9qPx9WTCkgDm2B+eMrwehGtHBWHFU4GXvnSCNiFhhausg==",
      "license": "MIT",
      "dependencies": {
        "sparse-bitfield": "^3.0.3"
      }
    },
    "node_modules/@peculiar/asn1-schema": {
      "version": "2.3.15",
      "resolved": "https://registry.npmjs.org/@peculiar/asn1-schema/-/asn1-schema-2.3.15.tgz",
      "integrity": "sha512-QPeD8UA8axQREpgR5UTAfu2mqQmm97oUqahDtNdBcfj3qAnoXzFdQW+aNf/tD2WVXF8Fhmftxoj0eMIT++gX2w==",
      "license": "MIT",
      "dependencies": {
        "asn1js": "^3.0.5",
        "pvtsutils": "^1.3.6",
        "tslib": "^2.8.1"
      }
    },
    "node_modules/@peculiar/asn1-schema/node_modules/tslib": {
      "version": "2.8.1",
      "resolved": "https://registry.npmjs.org/tslib/-/tslib-2.8.1.tgz",
      "integrity": "sha512-oJFu94HQb+KVduSUQL7wnpmqnfmLsOA/nAh6b6EH0wCEoK0/mPeXU6c3wKDV83MkOuHPRHtSXKKU99IBazS/2w==",
      "license": "0BSD"
    },
    "node_modules/@peculiar/json-schema": {
      "version": "1.1.12",
      "resolved": "https://registry.npmjs.org/@peculiar/json-schema/-/json-schema-1.1.12.tgz",
      "integrity": "sha512-coUfuoMeIB7B8/NMekxaDzLhaYmp0HZNPEjYRm9goRou8UZIC3z21s0sL9AWoCw4EG876QyO3kYrc61WNF9B/w==",
      "license": "MIT",
      "dependencies": {
        "tslib": "^2.0.0"
      },
      "engines": {
        "node": ">=8.0.0"
      }
    },
    "node_modules/@peculiar/webcrypto": {
      "version": "1.4.1",
      "resolved": "https://registry.npmjs.org/@peculiar/webcrypto/-/webcrypto-1.4.1.tgz",
      "integrity": "sha512-eK4C6WTNYxoI7JOabMoZICiyqRRtJB220bh0Mbj5RwRycleZf9BPyZoxsTvpP0FpmVS2aS13NKOuh5/tN3sIRw==",
      "license": "MIT",
      "dependencies": {
        "@peculiar/asn1-schema": "^2.3.0",
        "@peculiar/json-schema": "^1.1.12",
        "pvtsutils": "^1.3.2",
        "tslib": "^2.4.1",
        "webcrypto-core": "^1.7.4"
      },
      "engines": {
        "node": ">=10.12.0"
      }
    },
    "node_modules/@types/body-parser": {
      "version": "1.19.5",
      "resolved": "https://registry.npmjs.org/@types/body-parser/-/body-parser-1.19.5.tgz",
      "integrity": "sha512-fB3Zu92ucau0iQ0JMCFQE7b/dv8Ot07NI3KaZIkIUNXq82k4eBAqUaneXfleGY9JWskeS9y+u0nXMyspcuQrCg==",
      "license": "MIT",
      "dependencies": {
        "@types/connect": "*",
        "@types/node": "*"
      }
    },
    "node_modules/@types/connect": {
      "version": "3.4.38",
      "resolved": "https://registry.npmjs.org/@types/connect/-/connect-3.4.38.tgz",
      "integrity": "sha512-K6uROf1LD88uDQqJCktA4yzL1YYAK6NgfsI0v/mTgyPKWsX1CnJ0XPSDhViejru1GcRkLWb8RlzFYJRqGUbaug==",
      "license": "MIT",
      "dependencies": {
        "@types/node": "*"
      }
    },
    "node_modules/@types/cookies": {
      "version": "0.7.7",
      "resolved": "https://registry.npmjs.org/@types/cookies/-/cookies-0.7.7.tgz",
      "integrity": "sha512-h7BcvPUogWbKCzBR2lY4oqaZbO3jXZksexYJVFvkrFeLgbZjQkU4x8pRq6eg2MHXQhY0McQdqmmsxRWlVAHooA==",
      "license": "MIT",
      "dependencies": {
        "@types/connect": "*",
        "@types/express": "*",
        "@types/keygrip": "*",
        "@types/node": "*"
      }
    },
    "node_modules/@types/express": {
      "version": "4.17.14",
      "resolved": "https://registry.npmjs.org/@types/express/-/express-4.17.14.tgz",
      "integrity": "sha512-TEbt+vaPFQ+xpxFLFssxUDXj5cWCxZJjIcB7Yg0k0GMHGtgtQgpvx/MUQUeAkNbA9AAGrwkAsoeItdTgS7FMyg==",
      "license": "MIT",
      "dependencies": {
        "@types/body-parser": "*",
        "@types/express-serve-static-core": "^4.17.18",
        "@types/qs": "*",
        "@types/serve-static": "*"
      }
    },
    "node_modules/@types/express-serve-static-core": {
      "version": "4.19.6",
      "resolved": "https://registry.npmjs.org/@types/express-serve-static-core/-/express-serve-static-core-4.19.6.tgz",
      "integrity": "sha512-N4LZ2xG7DatVqhCZzOGb1Yi5lMbXSZcmdLDe9EzSndPV2HpWYWzRbaerl2n27irrm94EPpprqa8KpskPT085+A==",
      "license": "MIT",
      "dependencies": {
        "@types/node": "*",
        "@types/qs": "*",
        "@types/range-parser": "*",
        "@types/send": "*"
      }
    },
    "node_modules/@types/http-errors": {
      "version": "2.0.4",
      "resolved": "https://registry.npmjs.org/@types/http-errors/-/http-errors-2.0.4.tgz",
      "integrity": "sha512-D0CFMMtydbJAegzOyHjtiKPLlvnm3iTZyZRSZoLq2mRhDdmLfIWOCYPfQJ4cu2erKghU++QvjcUjp/5h7hESpA==",
      "license": "MIT"
    },
    "node_modules/@types/keygrip": {
      "version": "1.0.6",
      "resolved": "https://registry.npmjs.org/@types/keygrip/-/keygrip-1.0.6.tgz",
      "integrity": "sha512-lZuNAY9xeJt7Bx4t4dx0rYCDqGPW8RXhQZK1td7d4H6E9zYbLoOtjBvfwdTKpsyxQI/2jv+armjX/RW+ZNpXOQ==",
      "license": "MIT"
    },
    "node_modules/@types/mime": {
      "version": "1.3.5",
      "resolved": "https://registry.npmjs.org/@types/mime/-/mime-1.3.5.tgz",
      "integrity": "sha512-/pyBZWSLD2n0dcHE3hq8s8ZvcETHtEuF+3E7XVt0Ig2nvsVQXdghHVcEkIWjy9A0wKfTn97a/PSDYohKIlnP/w==",
      "license": "MIT"
    },
    "node_modules/@types/node": {
      "version": "16.18.6",
      "resolved": "https://registry.npmjs.org/@types/node/-/node-16.18.6.tgz",
      "integrity": "sha512-vmYJF0REqDyyU0gviezF/KHq/fYaUbFhkcNbQCuPGFQj6VTbXuHZoxs/Y7mutWe73C8AC6l9fFu8mSYiBAqkGA==",
      "license": "MIT"
    },
    "node_modules/@types/node-fetch": {
      "version": "2.6.2",
      "resolved": "https://registry.npmjs.org/@types/node-fetch/-/node-fetch-2.6.2.tgz",
      "integrity": "sha512-DHqhlq5jeESLy19TYhLakJ07kNumXWjcDdxXsLUMJZ6ue8VZJj4kLPQVE/2mdHh3xZziNF1xppu5lwmS53HR+A==",
      "license": "MIT",
      "dependencies": {
        "@types/node": "*",
        "form-data": "^3.0.0"
      }
    },
    "node_modules/@types/qs": {
      "version": "6.9.18",
      "resolved": "https://registry.npmjs.org/@types/qs/-/qs-6.9.18.tgz",
      "integrity": "sha512-kK7dgTYDyGqS+e2Q4aK9X3D7q234CIZ1Bv0q/7Z5IwRDoADNU81xXJK/YVyLbLTZCoIwUoDoffFeF+p/eIklAA==",
      "license": "MIT"
    },
    "node_modules/@types/range-parser": {
      "version": "1.2.7",
      "resolved": "https://registry.npmjs.org/@types/range-parser/-/range-parser-1.2.7.tgz",
      "integrity": "sha512-hKormJbkJqzQGhziax5PItDUTMAM9uE2XXQmM37dyd4hVM+5aVl7oVxMVUiVQn2oCQFN/LKCZdvSM0pFRqbSmQ==",
      "license": "MIT"
    },
    "node_modules/@types/send": {
      "version": "0.17.4",
      "resolved": "https://registry.npmjs.org/@types/send/-/send-0.17.4.tgz",
      "integrity": "sha512-x2EM6TJOybec7c52BX0ZspPodMsQUd5L6PRwOunVyVUhXiBSKf3AezDL8Dgvgt5o0UfKNfuA0eMLr2wLT4AiBA==",
      "license": "MIT",
      "dependencies": {
        "@types/mime": "^1",
        "@types/node": "*"
      }
    },
    "node_modules/@types/serve-static": {
      "version": "1.15.7",
      "resolved": "https://registry.npmjs.org/@types/serve-static/-/serve-static-1.15.7.tgz",
      "integrity": "sha512-W8Ym+h8nhuRwaKPaDw34QUkwsGi6Rc4yYqvKFo5rm2FUEhCFbzVWrxXUxuKK8TASjWsysJY0nsmNCGhCOIsrOw==",
      "license": "MIT",
      "dependencies": {
        "@types/http-errors": "*",
        "@types/node": "*",
        "@types/send": "*"
      }
    },
    "node_modules/@types/webidl-conversions": {
      "version": "7.0.3",
      "resolved": "https://registry.npmjs.org/@types/webidl-conversions/-/webidl-conversions-7.0.3.tgz",
      "integrity": "sha512-CiJJvcRtIgzadHCYXw7dqEnMNRjhGZlYK05Mj9OyktqV8uVT8fD2BFOB7S1uwBE3Kj2Z+4UyPmFw/Ixgw/LAlA==",
      "license": "MIT"
    },
    "node_modules/@types/whatwg-url": {
      "version": "11.0.5",
      "resolved": "https://registry.npmjs.org/@types/whatwg-url/-/whatwg-url-11.0.5.tgz",
      "integrity": "sha512-coYR071JRaHa+xoEvvYqvnIHaVqaYrLPbsufM9BF63HkwI5Lgmy2QR8Q5K/lYDYo5AK82wOvSOS0UsLTpTG7uQ==",
      "license": "MIT",
      "dependencies": {
        "@types/webidl-conversions": "*"
      }
    },
    "node_modules/accepts": {
      "version": "1.3.8",
      "resolved": "https://registry.npmjs.org/accepts/-/accepts-1.3.8.tgz",
      "integrity": "sha512-PYAthTa2m2VKxuvSD3DPC/Gy+U+sOA1LAuT8mkmRuvw+NACSaeXEQ+NHcVF7rONl6qcaxV3Uuemwawk+7+SJLw==",
      "license": "MIT",
      "dependencies": {
        "mime-types": "~2.1.34",
        "negotiator": "0.6.3"
      },
      "engines": {
        "node": ">= 0.6"
      }
    },
    "node_modules/anymatch": {
      "version": "3.1.3",
      "resolved": "https://registry.npmjs.org/anymatch/-/anymatch-3.1.3.tgz",
      "integrity": "sha512-KMReFUr0B4t+D+OBkjR3KYqvocp2XaSzO55UcB6mgQMd3KbcE+mWTyvVV7D/zsdEbNnV6acZUutkiHQXvTr1Rw==",
      "license": "ISC",
      "dependencies": {
        "normalize-path": "^3.0.0",
        "picomatch": "^2.0.4"
      },
      "engines": {
        "node": ">= 8"
      }
    },
    "node_modules/array-flatten": {
      "version": "1.1.1",
      "resolved": "https://registry.npmjs.org/array-flatten/-/array-flatten-1.1.1.tgz",
      "integrity": "sha512-PCVAQswWemu6UdxsDFFX/+gVeYqKAod3D3UVm91jHwynguOwAvYPhx8nNlM++NqRcK6CxxpUafjmhIdKiHibqg==",
      "license": "MIT"
    },
    "node_modules/asn1js": {
      "version": "3.0.5",
      "resolved": "https://registry.npmjs.org/asn1js/-/asn1js-3.0.5.tgz",
      "integrity": "sha512-FVnvrKJwpt9LP2lAMl8qZswRNm3T4q9CON+bxldk2iwk3FFpuwhx2FfinyitizWHsVYyaY+y5JzDR0rCMV5yTQ==",
      "license": "BSD-3-Clause",
      "dependencies": {
        "pvtsutils": "^1.3.2",
        "pvutils": "^1.1.3",
        "tslib": "^2.4.0"
      },
      "engines": {
        "node": ">=12.0.0"
      }
    },
    "node_modules/asynckit": {
      "version": "0.4.0",
      "resolved": "https://registry.npmjs.org/asynckit/-/asynckit-0.4.0.tgz",
      "integrity": "sha512-Oei9OH4tRh0YqU3GxhX79dM/mwVgvbZJaSNaRk+bshkj0S5cfHcgYakreBjrHwatXKbz+IoIdYLxrKim2MjW0Q==",
      "license": "MIT"
    },
    "node_modules/balanced-match": {
      "version": "1.0.2",
      "resolved": "https://registry.npmjs.org/balanced-match/-/balanced-match-1.0.2.tgz",
      "integrity": "sha512-3oSeUO0TMV67hN1AmbXsK4yaqU7tjiHlbxRDZOpH0KW9+CeX4bRAaX0Anxt0tx2MrpRpWwQaPwIlISEJhYU5Pw==",
      "license": "MIT"
    },
    "node_modules/bcryptjs": {
      "version": "3.0.2",
      "resolved": "https://registry.npmjs.org/bcryptjs/-/bcryptjs-3.0.2.tgz",
      "integrity": "sha512-k38b3XOZKv60C4E2hVsXTolJWfkGRMbILBIe2IBITXciy5bOsTKot5kDrf3ZfufQtQOUN5mXceUEpU1rTl9Uog==",
      "license": "BSD-3-Clause",
      "bin": {
        "bcrypt": "bin/bcrypt"
      }
    },
    "node_modules/binary-extensions": {
      "version": "2.3.0",
      "resolved": "https://registry.npmjs.org/binary-extensions/-/binary-extensions-2.3.0.tgz",
      "integrity": "sha512-Ceh+7ox5qe7LJuLHoY0feh3pHuUDHAcRUeyL2VYghZwfpkNIy/+8Ocg0a3UuSoYzavmylwuLWQOf3hl0jjMMIw==",
      "license": "MIT",
      "engines": {
        "node": ">=8"
      },
      "funding": {
        "url": "https://github.com/sponsors/sindresorhus"
      }
    },
    "node_modules/body-parser": {
      "version": "1.20.3",
      "resolved": "https://registry.npmjs.org/body-parser/-/body-parser-1.20.3.tgz",
      "integrity": "sha512-7rAxByjUMqQ3/bHJy7D6OGXvx/MMc4IqBn/X0fcM1QUcAItpZrBEYhWGem+tzXH90c+G01ypMcYJBO9Y30203g==",
      "license": "MIT",
      "dependencies": {
        "bytes": "3.1.2",
        "content-type": "~1.0.5",
        "debug": "2.6.9",
        "depd": "2.0.0",
        "destroy": "1.2.0",
        "http-errors": "2.0.0",
        "iconv-lite": "0.4.24",
        "on-finished": "2.4.1",
        "qs": "6.13.0",
        "raw-body": "2.5.2",
        "type-is": "~1.6.18",
        "unpipe": "1.0.0"
      },
      "engines": {
        "node": ">= 0.8",
        "npm": "1.2.8000 || >= 1.4.16"
      }
    },
    "node_modules/brace-expansion": {
      "version": "1.1.11",
      "resolved": "https://registry.npmjs.org/brace-expansion/-/brace-expansion-1.1.11.tgz",
      "integrity": "sha512-iCuPHDFgrHX7H2vEI/5xpz07zSHB00TpugqhmYtVmMO6518mCuRMoOYFldEBl0g187ufozdaHgWKcYFb61qGiA==",
      "license": "MIT",
      "dependencies": {
        "balanced-match": "^1.0.0",
        "concat-map": "0.0.1"
      }
    },
    "node_modules/braces": {
      "version": "3.0.3",
      "resolved": "https://registry.npmjs.org/braces/-/braces-3.0.3.tgz",
      "integrity": "sha512-yQbXgO/OSZVD2IsiLlro+7Hf6Q18EJrKSEsdoMzKePKXct3gvD8oLcOQdIzGupr5Fj+EDe8gO/lxc1BzfMpxvA==",
      "license": "MIT",
      "dependencies": {
        "fill-range": "^7.1.1"
      },
      "engines": {
        "node": ">=8"
      }
    },
    "node_modules/bson": {
      "version": "6.10.3",
      "resolved": "https://registry.npmjs.org/bson/-/bson-6.10.3.tgz",
      "integrity": "sha512-MTxGsqgYTwfshYWTRdmZRC+M7FnG1b4y7RO7p2k3X24Wq0yv1m77Wsj0BzlPzd/IowgESfsruQCUToa7vbOpPQ==",
      "license": "Apache-2.0",
      "engines": {
        "node": ">=16.20.1"
      }
    },
    "node_modules/buffer-equal-constant-time": {
      "version": "1.0.1",
      "resolved": "https://registry.npmjs.org/buffer-equal-constant-time/-/buffer-equal-constant-time-1.0.1.tgz",
      "integrity": "sha512-zRpUiDwd/xk6ADqPMATG8vc9VPrkck7T07OIx0gnjmJAnHnTVXNQG3vfvWNuiZIkwu9KrKdA1iJKfsfTVxE6NA==",
      "license": "BSD-3-Clause"
    },
    "node_modules/bytes": {
      "version": "3.1.2",
      "resolved": "https://registry.npmjs.org/bytes/-/bytes-3.1.2.tgz",
      "integrity": "sha512-/Nf7TyzTx6S3yRJObOAV7956r8cr2+Oj8AC5dt8wSP3BQAoeX58NoHyCU8P8zGkNXStjTSi6fzO6F0pBdcYbEg==",
      "license": "MIT",
      "engines": {
        "node": ">= 0.8"
      }
    },
    "node_modules/call-bind-apply-helpers": {
      "version": "1.0.2",
      "resolved": "https://registry.npmjs.org/call-bind-apply-helpers/-/call-bind-apply-helpers-1.0.2.tgz",
      "integrity": "sha512-Sp1ablJ0ivDkSzjcaJdxEunN5/XvksFJ2sMBFfq6x0ryhQV/2b/KwFe21cMpmHtPOSij8K99/wSfoEuTObmuMQ==",
      "license": "MIT",
      "dependencies": {
        "es-errors": "^1.3.0",
        "function-bind": "^1.1.2"
      },
      "engines": {
        "node": ">= 0.4"
      }
    },
    "node_modules/call-bound": {
      "version": "1.0.4",
      "resolved": "https://registry.npmjs.org/call-bound/-/call-bound-1.0.4.tgz",
      "integrity": "sha512-+ys997U96po4Kx/ABpBCqhA9EuxJaQWDQg7295H4hBphv3IZg0boBKuwYpt4YXp6MZ5AmZQnU/tyMTlRpaSejg==",
      "license": "MIT",
      "dependencies": {
        "call-bind-apply-helpers": "^1.0.2",
        "get-intrinsic": "^1.3.0"
      },
      "engines": {
        "node": ">= 0.4"
      },
      "funding": {
        "url": "https://github.com/sponsors/ljharb"
      }
    },
    "node_modules/camelcase": {
      "version": "5.3.1",
      "resolved": "https://registry.npmjs.org/camelcase/-/camelcase-5.3.1.tgz",
      "integrity": "sha512-L28STB170nwWS63UjtlEOE3dldQApaJXZkOI1uMFfzf3rRuPegHaHesyee+YxQ+W6SvRDQV6UrdOdRiR153wJg==",
      "license": "MIT",
      "engines": {
        "node": ">=6"
      }
    },
    "node_modules/camelcase-keys": {
      "version": "6.2.2",
      "resolved": "https://registry.npmjs.org/camelcase-keys/-/camelcase-keys-6.2.2.tgz",
      "integrity": "sha512-YrwaA0vEKazPBkn0ipTiMpSajYDSe+KjQfrjhcBMxJt/znbvlHd8Pw/Vamaz5EB4Wfhs3SUR3Z9mwRu/P3s3Yg==",
      "license": "MIT",
      "dependencies": {
        "camelcase": "^5.3.1",
        "map-obj": "^4.0.0",
        "quick-lru": "^4.0.1"
      },
      "engines": {
        "node": ">=8"
      },
      "funding": {
        "url": "https://github.com/sponsors/sindresorhus"
      }
    },
    "node_modules/chokidar": {
      "version": "3.6.0",
      "resolved": "https://registry.npmjs.org/chokidar/-/chokidar-3.6.0.tgz",
      "integrity": "sha512-7VT13fmjotKpGipCW9JEQAusEPE+Ei8nl6/g4FBAmIm0GOOLMua9NDDo/DWp0ZAxCr3cPq5ZpBqmPAQgDda2Pw==",
      "license": "MIT",
      "dependencies": {
        "anymatch": "~3.1.2",
        "braces": "~3.0.2",
        "glob-parent": "~5.1.2",
        "is-binary-path": "~2.1.0",
        "is-glob": "~4.0.1",
        "normalize-path": "~3.0.0",
        "readdirp": "~3.6.0"
      },
      "engines": {
        "node": ">= 8.10.0"
      },
      "funding": {
        "url": "https://paulmillr.com/funding/"
      },
      "optionalDependencies": {
        "fsevents": "~2.3.2"
      }
    },
    "node_modules/combined-stream": {
      "version": "1.0.8",
      "resolved": "https://registry.npmjs.org/combined-stream/-/combined-stream-1.0.8.tgz",
      "integrity": "sha512-FQN4MRfuJeHf7cBbBMJFXhKSDq+2kAArBlmRBvcvFE5BB1HZKXtSFASDhdlz9zOYwxh8lDdnvmMOe/+5cdoEdg==",
      "license": "MIT",
      "dependencies": {
        "delayed-stream": "~1.0.0"
      },
      "engines": {
        "node": ">= 0.8"
      }
    },
    "node_modules/concat-map": {
      "version": "0.0.1",
      "resolved": "https://registry.npmjs.org/concat-map/-/concat-map-0.0.1.tgz",
      "integrity": "sha512-/Srv4dswyQNBfohGpz9o6Yb3Gz3SrUDqBH5rTuhGR7ahtlbYKnVxw2bCFMRljaA7EXHaXZ8wsHdodFvbkhKmqg==",
      "license": "MIT"
    },
    "node_modules/content-disposition": {
      "version": "0.5.4",
      "resolved": "https://registry.npmjs.org/content-disposition/-/content-disposition-0.5.4.tgz",
      "integrity": "sha512-FveZTNuGw04cxlAiWbzi6zTAL/lhehaWbTtgluJh4/E95DqMwTmha3KZN1aAWA8cFIhHzMZUvLevkw5Rqk+tSQ==",
      "license": "MIT",
      "dependencies": {
        "safe-buffer": "5.2.1"
      },
      "engines": {
        "node": ">= 0.6"
      }
    },
    "node_modules/content-type": {
      "version": "1.0.5",
      "resolved": "https://registry.npmjs.org/content-type/-/content-type-1.0.5.tgz",
      "integrity": "sha512-nTjqfcBFEipKdXCv4YDQWCfmcLZKm81ldF0pAopTvyrFGVbcR6P/VAAd5G7N+0tTr8QqiU0tFadD6FK4NtJwOA==",
      "license": "MIT",
      "engines": {
        "node": ">= 0.6"
      }
    },
    "node_modules/cookie": {
      "version": "0.7.1",
      "resolved": "https://registry.npmjs.org/cookie/-/cookie-0.7.1.tgz",
      "integrity": "sha512-6DnInpx7SJ2AK3+CTUE/ZM0vWTUboZCegxhC2xiIydHR9jNuTAASBrfEpHhiGOZw/nX51bHt6YQl8jsGo4y/0w==",
      "license": "MIT",
      "engines": {
        "node": ">= 0.6"
      }
    },
    "node_modules/cookie-signature": {
      "version": "1.0.6",
      "resolved": "https://registry.npmjs.org/cookie-signature/-/cookie-signature-1.0.6.tgz",
      "integrity": "sha512-QADzlaHc8icV8I7vbaJXJwod9HWYp8uCqf1xa4OfNu1T7JVxQIrUgOWtHdNDtPiywmFbiS12VjotIXLrKM3orQ==",
      "license": "MIT"
    },
    "node_modules/cors": {
      "version": "2.8.5",
      "resolved": "https://registry.npmjs.org/cors/-/cors-2.8.5.tgz",
      "integrity": "sha512-KIHbLJqu73RGr/hnbrO9uBeixNGuvSQjul/jdFvS/KFSIH1hWVd1ng7zOHx+YrEfInLG7q4n6GHQ9cDtxv/P6g==",
      "license": "MIT",
      "dependencies": {
        "object-assign": "^4",
        "vary": "^1"
      },
      "engines": {
        "node": ">= 0.10"
      }
    },
    "node_modules/csstype": {
      "version": "3.1.1",
      "resolved": "https://registry.npmjs.org/csstype/-/csstype-3.1.1.tgz",
      "integrity": "sha512-DJR/VvkAvSZW9bTouZue2sSxDwdTN92uHjqeKVm+0dAqdfNykRzQ95tay8aXMBAAPpUiq4Qcug2L7neoRh2Egw==",
      "license": "MIT"
    },
    "node_modules/debug": {
      "version": "2.6.9",
      "resolved": "https://registry.npmjs.org/debug/-/debug-2.6.9.tgz",
      "integrity": "sha512-bC7ElrdJaJnPbAP+1EotYvqZsb3ecl5wi6Bfi6BJTUcNowp6cvspg0jXznRTKDjm/E7AdgFBVeAPVMNcKGsHMA==",
      "license": "MIT",
      "dependencies": {
        "ms": "2.0.0"
      }
    },
    "node_modules/deepmerge": {
      "version": "4.2.2",
      "resolved": "https://registry.npmjs.org/deepmerge/-/deepmerge-4.2.2.tgz",
      "integrity": "sha512-FJ3UgI4gIl+PHZm53knsuSFpE+nESMr7M4v9QcgB7S63Kj/6WqMiFQJpBBYz1Pt+66bZpP3Q7Lye0Oo9MPKEdg==",
      "license": "MIT",
      "engines": {
        "node": ">=0.10.0"
      }
    },
    "node_modules/delayed-stream": {
      "version": "1.0.0",
      "resolved": "https://registry.npmjs.org/delayed-stream/-/delayed-stream-1.0.0.tgz",
      "integrity": "sha512-ZySD7Nf91aLB0RxL4KGrKHBXl7Eds1DAmEdcoVawXnLD7SDhpNgtuII2aAkg7a7QS41jxPSZ17p4VdGnMHk3MQ==",
      "license": "MIT",
      "engines": {
        "node": ">=0.4.0"
      }
    },
    "node_modules/depd": {
      "version": "2.0.0",
      "resolved": "https://registry.npmjs.org/depd/-/depd-2.0.0.tgz",
      "integrity": "sha512-g7nH6P6dyDioJogAAGprGpCtVImJhpPk/roCzdb3fIh61/s/nPsfR6onyMwkCAR/OlC3yBC0lESvUoQEAssIrw==",
      "license": "MIT",
      "engines": {
        "node": ">= 0.8"
      }
    },
    "node_modules/destroy": {
      "version": "1.2.0",
      "resolved": "https://registry.npmjs.org/destroy/-/destroy-1.2.0.tgz",
      "integrity": "sha512-2sJGJTaXIIaR1w4iJSNoN0hnMY7Gpc/n8D4qSCJw8QqFWXf7cuAgnEHxBpweaVcPevC2l3KpjYCx3NypQQgaJg==",
      "license": "MIT",
      "engines": {
        "node": ">= 0.8",
        "npm": "1.2.8000 || >= 1.4.16"
      }
    },
    "node_modules/dot-case": {
      "version": "3.0.4",
      "resolved": "https://registry.npmjs.org/dot-case/-/dot-case-3.0.4.tgz",
      "integrity": "sha512-Kv5nKlh6yRrdrGvxeJ2e5y2eRUpkUosIW4A2AS38zwSz27zu7ufDwQPi5Jhs3XAlGNetl3bmnGhQsMtkKJnj3w==",
      "license": "MIT",
      "dependencies": {
        "no-case": "^3.0.4",
        "tslib": "^2.0.3"
      }
    },
    "node_modules/dotenv": {
      "version": "16.4.7",
      "resolved": "https://registry.npmjs.org/dotenv/-/dotenv-16.4.7.tgz",
      "integrity": "sha512-47qPchRCykZC03FhkYAhrvwU4xDBFIj1QPqaarj6mdM/hgUzfPHcpkHJOn3mJAufFeeAxAzeGsr5X0M4k6fLZQ==",
      "license": "BSD-2-Clause",
      "engines": {
        "node": ">=12"
      },
      "funding": {
        "url": "https://dotenvx.com"
      }
    },
    "node_modules/dunder-proto": {
      "version": "1.0.1",
      "resolved": "https://registry.npmjs.org/dunder-proto/-/dunder-proto-1.0.1.tgz",
      "integrity": "sha512-KIN/nDJBQRcXw0MLVhZE9iQHmG68qAVIBg9CqmUYjmQIhgij9U5MFvrqkUL5FbtyyzZuOeOt0zdeRe4UY7ct+A==",
      "license": "MIT",
      "dependencies": {
        "call-bind-apply-helpers": "^1.0.1",
        "es-errors": "^1.3.0",
        "gopd": "^1.2.0"
      },
      "engines": {
        "node": ">= 0.4"
      }
    },
    "node_modules/ecdsa-sig-formatter": {
      "version": "1.0.11",
      "resolved": "https://registry.npmjs.org/ecdsa-sig-formatter/-/ecdsa-sig-formatter-1.0.11.tgz",
      "integrity": "sha512-nagl3RYrbNv6kQkeJIpt6NJZy8twLB/2vtz6yN9Z4vRKHN4/QZJIEbqohALSgwKdnksuY3k5Addp5lg8sVoVcQ==",
      "license": "Apache-2.0",
      "dependencies": {
        "safe-buffer": "^5.0.1"
      }
    },
    "node_modules/ee-first": {
      "version": "1.1.1",
      "resolved": "https://registry.npmjs.org/ee-first/-/ee-first-1.1.1.tgz",
      "integrity": "sha512-WMwm9LhRUo+WUaRN+vRuETqG89IgZphVSNkdFgeb6sS/E4OrDIN7t48CAewSHXc6C8lefD8KKfr5vY61brQlow==",
      "license": "MIT"
    },
    "node_modules/encodeurl": {
      "version": "2.0.0",
      "resolved": "https://registry.npmjs.org/encodeurl/-/encodeurl-2.0.0.tgz",
      "integrity": "sha512-Q0n9HRi4m6JuGIV1eFlmvJB7ZEVxu93IrMyiMsGC0lrMJMWzRgx6WGquyfQgZVb31vhGgXnfmPNNXmxnOkRBrg==",
      "license": "MIT",
      "engines": {
        "node": ">= 0.8"
      }
    },
    "node_modules/es-define-property": {
      "version": "1.0.1",
      "resolved": "https://registry.npmjs.org/es-define-property/-/es-define-property-1.0.1.tgz",
      "integrity": "sha512-e3nRfgfUZ4rNGL232gUgX06QNyyez04KdjFrF+LTRoOXmrOgFKDg4BCdsjW8EnT69eqdYGmRpJwiPVYNrCaW3g==",
      "license": "MIT",
      "engines": {
        "node": ">= 0.4"
      }
    },
    "node_modules/es-errors": {
      "version": "1.3.0",
      "resolved": "https://registry.npmjs.org/es-errors/-/es-errors-1.3.0.tgz",
      "integrity": "sha512-Zf5H2Kxt2xjTvbJvP2ZWLEICxA6j+hAmMzIlypy4xcBg1vKVnx89Wy0GbS+kf5cwCVFFzdCFh2XSCFNULS6csw==",
      "license": "MIT",
      "engines": {
        "node": ">= 0.4"
      }
    },
    "node_modules/es-object-atoms": {
      "version": "1.1.1",
      "resolved": "https://registry.npmjs.org/es-object-atoms/-/es-object-atoms-1.1.1.tgz",
      "integrity": "sha512-FGgH2h8zKNim9ljj7dankFPcICIK9Cp5bm+c2gQSYePhpaG5+esrLODihIorn+Pe6FGJzWhXQotPv73jTaldXA==",
      "license": "MIT",
      "dependencies": {
        "es-errors": "^1.3.0"
      },
      "engines": {
        "node": ">= 0.4"
      }
    },
    "node_modules/es-set-tostringtag": {
      "version": "2.1.0",
      "resolved": "https://registry.npmjs.org/es-set-tostringtag/-/es-set-tostringtag-2.1.0.tgz",
      "integrity": "sha512-j6vWzfrGVfyXxge+O0x5sh6cvxAog0a/4Rdd2K36zCMV5eJ+/+tOAngRO8cODMNWbVRdVlmGZQL2YS3yR8bIUA==",
      "license": "MIT",
      "dependencies": {
        "es-errors": "^1.3.0",
        "get-intrinsic": "^1.2.6",
        "has-tostringtag": "^1.0.2",
        "hasown": "^2.0.2"
      },
      "engines": {
        "node": ">= 0.4"
      }
    },
    "node_modules/escape-html": {
      "version": "1.0.3",
      "resolved": "https://registry.npmjs.org/escape-html/-/escape-html-1.0.3.tgz",
      "integrity": "sha512-NiSupZ4OeuGwr68lGIeym/ksIZMJodUGOSCZ/FSnTxcrekbvqrgdUxlJOMpijaKZVjAJrWrGs/6Jy8OMuyj9ow==",
      "license": "MIT"
    },
    "node_modules/etag": {
      "version": "1.8.1",
      "resolved": "https://registry.npmjs.org/etag/-/etag-1.8.1.tgz",
      "integrity": "sha512-aIL5Fx7mawVa300al2BnEE4iNvo1qETxLrPI/o05L7z6go7fCw1J6EQmbK4FmJ2AS7kgVF/KEZWufBfdClMcPg==",
      "license": "MIT",
      "engines": {
        "node": ">= 0.6"
      }
    },
    "node_modules/express": {
      "version": "4.21.2",
      "resolved": "https://registry.npmjs.org/express/-/express-4.21.2.tgz",
      "integrity": "sha512-28HqgMZAmih1Czt9ny7qr6ek2qddF4FclbMzwhCREB6OFfH+rXAnuNCwo1/wFvrtbgsQDb4kSbX9de9lFbrXnA==",
      "license": "MIT",
      "dependencies": {
        "accepts": "~1.3.8",
        "array-flatten": "1.1.1",
        "body-parser": "1.20.3",
        "content-disposition": "0.5.4",
        "content-type": "~1.0.4",
        "cookie": "0.7.1",
        "cookie-signature": "1.0.6",
        "debug": "2.6.9",
        "depd": "2.0.0",
        "encodeurl": "~2.0.0",
        "escape-html": "~1.0.3",
        "etag": "~1.8.1",
        "finalhandler": "1.3.1",
        "fresh": "0.5.2",
        "http-errors": "2.0.0",
        "merge-descriptors": "1.0.3",
        "methods": "~1.1.2",
        "on-finished": "2.4.1",
        "parseurl": "~1.3.3",
        "path-to-regexp": "0.1.12",
        "proxy-addr": "~2.0.7",
        "qs": "6.13.0",
        "range-parser": "~1.2.1",
        "safe-buffer": "5.2.1",
        "send": "0.19.0",
        "serve-static": "1.16.2",
        "setprototypeof": "1.2.0",
        "statuses": "2.0.1",
        "type-is": "~1.6.18",
        "utils-merge": "1.0.1",
        "vary": "~1.1.2"
      },
      "engines": {
        "node": ">= 0.10.0"
      },
      "funding": {
        "type": "opencollective",
        "url": "https://opencollective.com/express"
      }
    },
    "node_modules/express-async-errors": {
      "version": "3.1.1",
      "resolved": "https://registry.npmjs.org/express-async-errors/-/express-async-errors-3.1.1.tgz",
      "integrity": "sha512-h6aK1da4tpqWSbyCa3FxB/V6Ehd4EEB15zyQq9qe75OZBp0krinNKuH4rAY+S/U/2I36vdLAUFSjQJ+TFmODng==",
      "license": "ISC",
      "peerDependencies": {
        "express": "^4.16.2"
      }
    },
    "node_modules/express-validator": {
      "version": "7.2.1",
      "resolved": "https://registry.npmjs.org/express-validator/-/express-validator-7.2.1.tgz",
      "integrity": "sha512-CjNE6aakfpuwGaHQZ3m8ltCG2Qvivd7RHtVMS/6nVxOM7xVGqr4bhflsm4+N5FP5zI7Zxp+Hae+9RE+o8e3ZOQ==",
      "license": "MIT",
      "dependencies": {
        "lodash": "^4.17.21",
        "validator": "~13.12.0"
      },
      "engines": {
        "node": ">= 8.0.0"
      }
    },
    "node_modules/fill-range": {
      "version": "7.1.1",
      "resolved": "https://registry.npmjs.org/fill-range/-/fill-range-7.1.1.tgz",
      "integrity": "sha512-YsGpe3WHLK8ZYi4tWDg2Jy3ebRz2rXowDxnld4bkQB00cc/1Zw9AWnC0i9ztDJitivtQvaI9KaLyKrc+hBW0yg==",
      "license": "MIT",
      "dependencies": {
        "to-regex-range": "^5.0.1"
      },
      "engines": {
        "node": ">=8"
      }
    },
    "node_modules/finalhandler": {
      "version": "1.3.1",
      "resolved": "https://registry.npmjs.org/finalhandler/-/finalhandler-1.3.1.tgz",
      "integrity": "sha512-6BN9trH7bp3qvnrRyzsBz+g3lZxTNZTbVO2EV1CS0WIcDbawYVdYvGflME/9QP0h0pYlCDBCTjYa9nZzMDpyxQ==",
      "license": "MIT",
      "dependencies": {
        "debug": "2.6.9",
        "encodeurl": "~2.0.0",
        "escape-html": "~1.0.3",
        "on-finished": "2.4.1",
        "parseurl": "~1.3.3",
        "statuses": "2.0.1",
        "unpipe": "~1.0.0"
      },
      "engines": {
        "node": ">= 0.8"
      }
    },
    "node_modules/form-data": {
      "version": "3.0.3",
      "resolved": "https://registry.npmjs.org/form-data/-/form-data-3.0.3.tgz",
      "integrity": "sha512-q5YBMeWy6E2Un0nMGWMgI65MAKtaylxfNJGJxpGh45YDciZB4epbWpaAfImil6CPAPTYB4sh0URQNDRIZG5F2w==",
      "license": "MIT",
      "dependencies": {
        "asynckit": "^0.4.0",
        "combined-stream": "^1.0.8",
        "es-set-tostringtag": "^2.1.0",
        "mime-types": "^2.1.35"
      },
      "engines": {
        "node": ">= 6"
      }
    },
    "node_modules/forwarded": {
      "version": "0.2.0",
      "resolved": "https://registry.npmjs.org/forwarded/-/forwarded-0.2.0.tgz",
      "integrity": "sha512-buRG0fpBtRHSTCOASe6hD258tEubFoRLb4ZNA6NxMVHNw2gOcwHo9wyablzMzOA5z9xA9L1KNjk/Nt6MT9aYow==",
      "license": "MIT",
      "engines": {
        "node": ">= 0.6"
      }
    },
    "node_modules/fresh": {
      "version": "0.5.2",
      "resolved": "https://registry.npmjs.org/fresh/-/fresh-0.5.2.tgz",
      "integrity": "sha512-zJ2mQYM18rEFOudeV4GShTGIQ7RbzA7ozbU9I/XBpm7kqgMywgmylMwXHxZJmkVoYkna9d2pVXVXPdYTP9ej8Q==",
      "license": "MIT",
      "engines": {
        "node": ">= 0.6"
      }
    },
    "node_modules/fsevents": {
      "version": "2.3.3",
      "resolved": "https://registry.npmjs.org/fsevents/-/fsevents-2.3.3.tgz",
      "integrity": "sha512-5xoDfX+fL7faATnagmWPpbFtwh/R77WmMMqqHGS65C3vvB0YHrgF+B1YmZ3441tMj5n63k0212XNoJwzlhffQw==",
      "hasInstallScript": true,
      "license": "MIT",
      "optional": true,
      "os": [
        "darwin"
      ],
      "engines": {
        "node": "^8.16.0 || ^10.6.0 || >=11.0.0"
      }
    },
    "node_modules/function-bind": {
      "version": "1.1.2",
      "resolved": "https://registry.npmjs.org/function-bind/-/function-bind-1.1.2.tgz",
      "integrity": "sha512-7XHNxH7qX9xG5mIwxkhumTox/MIRNcOgDrxWsMt2pAr23WHp6MrRlN7FBSFpCpr+oVO0F744iUgR82nJMfG2SA==",
      "license": "MIT",
      "funding": {
        "url": "https://github.com/sponsors/ljharb"
      }
    },
    "node_modules/get-intrinsic": {
      "version": "1.3.0",
      "resolved": "https://registry.npmjs.org/get-intrinsic/-/get-intrinsic-1.3.0.tgz",
      "integrity": "sha512-9fSjSaos/fRIVIp+xSJlE6lfwhES7LNtKaCBIamHsjr2na1BiABJPo0mOjjz8GJDURarmCPGqaiVg5mfjb98CQ==",
      "license": "MIT",
      "dependencies": {
        "call-bind-apply-helpers": "^1.0.2",
        "es-define-property": "^1.0.1",
        "es-errors": "^1.3.0",
        "es-object-atoms": "^1.1.1",
        "function-bind": "^1.1.2",
        "get-proto": "^1.0.1",
        "gopd": "^1.2.0",
        "has-symbols": "^1.1.0",
        "hasown": "^2.0.2",
        "math-intrinsics": "^1.1.0"
      },
      "engines": {
        "node": ">= 0.4"
      },
      "funding": {
        "url": "https://github.com/sponsors/ljharb"
      }
    },
    "node_modules/get-proto": {
      "version": "1.0.1",
      "resolved": "https://registry.npmjs.org/get-proto/-/get-proto-1.0.1.tgz",
      "integrity": "sha512-sTSfBjoXBp89JvIKIefqw7U2CCebsc74kiY6awiGogKtoSGbgjYE/G/+l9sF3MWFPNc9IcoOC4ODfKHfxFmp0g==",
      "license": "MIT",
      "dependencies": {
        "dunder-proto": "^1.0.1",
        "es-object-atoms": "^1.0.0"
      },
      "engines": {
        "node": ">= 0.4"
      }
    },
    "node_modules/glob-parent": {
      "version": "5.1.2",
      "resolved": "https://registry.npmjs.org/glob-parent/-/glob-parent-5.1.2.tgz",
      "integrity": "sha512-AOIgSQCepiJYwP3ARnGx+5VnTu2HBYdzbGP45eLw1vr3zB3vZLeyed1sC9hnbcOc9/SrMyM5RPQrkGz4aS9Zow==",
      "license": "ISC",
      "dependencies": {
        "is-glob": "^4.0.1"
      },
      "engines": {
        "node": ">= 6"
      }
    },
    "node_modules/glob-to-regexp": {
      "version": "0.4.1",
      "resolved": "https://registry.npmjs.org/glob-to-regexp/-/glob-to-regexp-0.4.1.tgz",
      "integrity": "sha512-lkX1HJXwyMcprw/5YUZc2s7DrpAiHB21/V+E1rHUrVNokkvB6bqMzT0VfV6/86ZNabt1k14YOIaT7nDvOX3Iiw==",
      "license": "BSD-2-Clause"
    },
    "node_modules/gopd": {
      "version": "1.2.0",
      "resolved": "https://registry.npmjs.org/gopd/-/gopd-1.2.0.tgz",
      "integrity": "sha512-ZUKRh6/kUFoAiTAtTYPZJ3hw9wNxx+BIBOijnlG9PnrJsCcSjs1wyyD6vJpaYtgnzDrKYRSqf3OO6Rfa93xsRg==",
      "license": "MIT",
      "engines": {
        "node": ">= 0.4"
      },
      "funding": {
        "url": "https://github.com/sponsors/ljharb"
      }
    },
    "node_modules/has-flag": {
      "version": "3.0.0",
      "resolved": "https://registry.npmjs.org/has-flag/-/has-flag-3.0.0.tgz",
      "integrity": "sha512-sKJf1+ceQBr4SMkvQnBDNDtf4TXpVhVGateu0t918bl30FnbE2m4vNLX+VWe/dpjlb+HugGYzW7uQXH98HPEYw==",
      "license": "MIT",
      "engines": {
        "node": ">=4"
      }
    },
    "node_modules/has-symbols": {
      "version": "1.1.0",
      "resolved": "https://registry.npmjs.org/has-symbols/-/has-symbols-1.1.0.tgz",
      "integrity": "sha512-1cDNdwJ2Jaohmb3sg4OmKaMBwuC48sYni5HUw2DvsC8LjGTLK9h+eb1X6RyuOHe4hT0ULCW68iomhjUoKUqlPQ==",
      "license": "MIT",
      "engines": {
        "node": ">= 0.4"
      },
      "funding": {
        "url": "https://github.com/sponsors/ljharb"
      }
    },
    "node_modules/has-tostringtag": {
      "version": "1.0.2",
      "resolved": "https://registry.npmjs.org/has-tostringtag/-/has-tostringtag-1.0.2.tgz",
      "integrity": "sha512-NqADB8VjPFLM2V0VvHUewwwsw0ZWBaIdgo+ieHtK3hasLz4qeCRjYcqfB6AQrBggRKppKF8L52/VqdVsO47Dlw==",
      "license": "MIT",
      "dependencies": {
        "has-symbols": "^1.0.3"
      },
      "engines": {
        "node": ">= 0.4"
      },
      "funding": {
        "url": "https://github.com/sponsors/ljharb"
      }
    },
    "node_modules/hasown": {
      "version": "2.0.2",
      "resolved": "https://registry.npmjs.org/hasown/-/hasown-2.0.2.tgz",
      "integrity": "sha512-0hJU9SCPvmMzIBdZFqNPXWa6dqh7WdH0cII9y+CyS8rG3nL48Bclra9HmKhVVUHyPWNH5Y7xDwAB7bfgSjkUMQ==",
      "license": "MIT",
      "dependencies": {
        "function-bind": "^1.1.2"
      },
      "engines": {
        "node": ">= 0.4"
      }
    },
    "node_modules/http-errors": {
      "version": "2.0.0",
      "resolved": "https://registry.npmjs.org/http-errors/-/http-errors-2.0.0.tgz",
      "integrity": "sha512-FtwrG/euBzaEjYeRqOgly7G0qviiXoJWnvEH2Z1plBdXgbyjv34pHTSb9zoeHMyDy33+DWy5Wt9Wo+TURtOYSQ==",
      "license": "MIT",
      "dependencies": {
        "depd": "2.0.0",
        "inherits": "2.0.4",
        "setprototypeof": "1.2.0",
        "statuses": "2.0.1",
        "toidentifier": "1.0.1"
      },
      "engines": {
        "node": ">= 0.8"
      }
    },
    "node_modules/iconv-lite": {
      "version": "0.4.24",
      "resolved": "https://registry.npmjs.org/iconv-lite/-/iconv-lite-0.4.24.tgz",
      "integrity": "sha512-v3MXnZAcvnywkTUEZomIActle7RXXeedOR31wwl7VlyoXO4Qi9arvSenNQWne1TcRwhCL1HwLI21bEqdpj8/rA==",
      "license": "MIT",
      "dependencies": {
        "safer-buffer": ">= 2.1.2 < 3"
      },
      "engines": {
        "node": ">=0.10.0"
      }
    },
    "node_modules/ignore-by-default": {
      "version": "1.0.1",
      "resolved": "https://registry.npmjs.org/ignore-by-default/-/ignore-by-default-1.0.1.tgz",
      "integrity": "sha512-Ius2VYcGNk7T90CppJqcIkS5ooHUZyIQK+ClZfMfMNFEF9VSE73Fq+906u/CWu92x4gzZMWOwfFYckPObzdEbA==",
      "license": "ISC"
    },
    "node_modules/inherits": {
      "version": "2.0.4",
      "resolved": "https://registry.npmjs.org/inherits/-/inherits-2.0.4.tgz",
      "integrity": "sha512-k/vGaX4/Yla3WzyMCvTQOXYeIHvqOKtnqBduzTHpzpQZzAskKMhZ2K+EnBiSM9zGSoIFeMpXKxa4dYeZIQqewQ==",
      "license": "ISC"
    },
    "node_modules/ipaddr.js": {
      "version": "1.9.1",
      "resolved": "https://registry.npmjs.org/ipaddr.js/-/ipaddr.js-1.9.1.tgz",
      "integrity": "sha512-0KI/607xoxSToH7GjN1FfSbLoU0+btTicjsQSWQlh/hZykN8KpmMf7uYwPW3R+akZ6R/w18ZlXSHBYXiYUPO3g==",
      "license": "MIT",
      "engines": {
        "node": ">= 0.10"
      }
    },
    "node_modules/is-binary-path": {
      "version": "2.1.0",
      "resolved": "https://registry.npmjs.org/is-binary-path/-/is-binary-path-2.1.0.tgz",
      "integrity": "sha512-ZMERYes6pDydyuGidse7OsHxtbI7WVeUEozgR/g7rd0xUimYNlvZRE/K2MgZTjWy725IfelLeVcEM97mmtRGXw==",
      "license": "MIT",
      "dependencies": {
        "binary-extensions": "^2.0.0"
      },
      "engines": {
        "node": ">=8"
      }
    },
    "node_modules/is-extglob": {
      "version": "2.1.1",
      "resolved": "https://registry.npmjs.org/is-extglob/-/is-extglob-2.1.1.tgz",
      "integrity": "sha512-SbKbANkN603Vi4jEZv49LeVJMn4yGwsbzZworEoyEiutsN3nJYdbO36zfhGJ6QEDpOZIFkDtnq5JRxmvl3jsoQ==",
      "license": "MIT",
      "engines": {
        "node": ">=0.10.0"
      }
    },
    "node_modules/is-glob": {
      "version": "4.0.3",
      "resolved": "https://registry.npmjs.org/is-glob/-/is-glob-4.0.3.tgz",
      "integrity": "sha512-xelSayHH36ZgE7ZWhli7pW34hNbNl8Ojv5KVmkJD4hBdD3th8Tfk9vYasLM+mXWOZhFkgZfxhLSnrwRr4elSSg==",
      "license": "MIT",
      "dependencies": {
        "is-extglob": "^2.1.1"
      },
      "engines": {
        "node": ">=0.10.0"
      }
    },
    "node_modules/is-number": {
      "version": "7.0.0",
      "resolved": "https://registry.npmjs.org/is-number/-/is-number-7.0.0.tgz",
      "integrity": "sha512-41Cifkg6e8TylSpdtTpeLVMqvSBEVzTttHvERD741+pnZ8ANv0004MRL43QKPDlK9cGvNp6NZWZUBlbGXYxxng==",
      "license": "MIT",
      "engines": {
        "node": ">=0.12.0"
      }
    },
    "node_modules/js-cookie": {
      "version": "3.0.1",
      "resolved": "https://registry.npmjs.org/js-cookie/-/js-cookie-3.0.1.tgz",
      "integrity": "sha512-+0rgsUXZu4ncpPxRL+lNEptWMOWl9etvPHc/koSRp6MPwpRYAhmk0dUG00J4bxVV3r9uUzfo24wW0knS07SKSw==",
      "license": "MIT",
      "engines": {
        "node": ">=12"
      }
    },
    "node_modules/js-tokens": {
      "version": "4.0.0",
      "resolved": "https://registry.npmjs.org/js-tokens/-/js-tokens-4.0.0.tgz",
      "integrity": "sha512-RdJUflcE3cUzKiMqQgsCu06FPu9UdIJO0beYbPhHN4k6apgJtifcoCtT9bcxOpYBtpD2kCM6Sbzg4CausW/PKQ==",
      "license": "MIT",
      "peer": true
    },
    "node_modules/jsonwebtoken": {
      "version": "9.0.2",
      "resolved": "https://registry.npmjs.org/jsonwebtoken/-/jsonwebtoken-9.0.2.tgz",
      "integrity": "sha512-PRp66vJ865SSqOlgqS8hujT5U4AOgMfhrwYIuIhfKaoSCZcirrmASQr8CX7cUg+RMih+hgznrjp99o+W4pJLHQ==",
      "license": "MIT",
      "dependencies": {
        "jws": "^3.2.2",
        "lodash.includes": "^4.3.0",
        "lodash.isboolean": "^3.0.3",
        "lodash.isinteger": "^4.0.4",
        "lodash.isnumber": "^3.0.3",
        "lodash.isplainobject": "^4.0.6",
        "lodash.isstring": "^4.0.1",
        "lodash.once": "^4.0.0",
        "ms": "^2.1.1",
        "semver": "^7.5.4"
      },
      "engines": {
        "node": ">=12",
        "npm": ">=6"
      }
    },
    "node_modules/jsonwebtoken/node_modules/ms": {
      "version": "2.1.3",
      "resolved": "https://registry.npmjs.org/ms/-/ms-2.1.3.tgz",
      "integrity": "sha512-6FlzubTLZG3J2a/NVCAleEhjzq5oxgHyaCU9yYXvcLsvoVaHJq/s5xXI6/XXP6tz7R9xAOtHnSO/tXtF3WRTlA==",
      "license": "MIT"
    },
    "node_modules/jwa": {
      "version": "1.4.1",
      "resolved": "https://registry.npmjs.org/jwa/-/jwa-1.4.1.tgz",
      "integrity": "sha512-qiLX/xhEEFKUAJ6FiBMbes3w9ATzyk5W7Hvzpa/SLYdxNtng+gcurvrI7TbACjIXlsJyr05/S1oUhZrc63evQA==",
      "license": "MIT",
      "dependencies": {
        "buffer-equal-constant-time": "1.0.1",
        "ecdsa-sig-formatter": "1.0.11",
        "safe-buffer": "^5.0.1"
      }
    },
    "node_modules/jws": {
      "version": "3.2.2",
      "resolved": "https://registry.npmjs.org/jws/-/jws-3.2.2.tgz",
      "integrity": "sha512-YHlZCB6lMTllWDtSPHz/ZXTsi8S00usEV6v1tjq8tOUZzw7DpSDWVXjXDre6ed1w/pd495ODpHZYSdkRTsa0HA==",
      "license": "MIT",
      "dependencies": {
        "jwa": "^1.4.1",
        "safe-buffer": "^5.0.1"
      }
    },
    "node_modules/kareem": {
      "version": "2.6.3",
      "resolved": "https://registry.npmjs.org/kareem/-/kareem-2.6.3.tgz",
      "integrity": "sha512-C3iHfuGUXK2u8/ipq9LfjFfXFxAZMQJJq7vLS45r3D9Y2xQ/m4S8zaR4zMLFWh9AsNPXmcFfUDhTEO8UIC/V6Q==",
      "license": "Apache-2.0",
      "engines": {
        "node": ">=12.0.0"
      }
    },
    "node_modules/lodash": {
      "version": "4.17.21",
      "resolved": "https://registry.npmjs.org/lodash/-/lodash-4.17.21.tgz",
      "integrity": "sha512-v2kDEe57lecTulaDIuNTPy3Ry4gLGJ6Z1O3vE1krgXZNrsQ+LFTGHVxVjcXPs17LhbZVGedAJv8XZ1tvj5FvSg==",
      "license": "MIT"
    },
    "node_modules/lodash.includes": {
      "version": "4.3.0",
      "resolved": "https://registry.npmjs.org/lodash.includes/-/lodash.includes-4.3.0.tgz",
      "integrity": "sha512-W3Bx6mdkRTGtlJISOvVD/lbqjTlPPUDTMnlXZFnVwi9NKJ6tiAk6LVdlhZMm17VZisqhKcgzpO5Wz91PCt5b0w==",
      "license": "MIT"
    },
    "node_modules/lodash.isboolean": {
      "version": "3.0.3",
      "resolved": "https://registry.npmjs.org/lodash.isboolean/-/lodash.isboolean-3.0.3.tgz",
      "integrity": "sha512-Bz5mupy2SVbPHURB98VAcw+aHh4vRV5IPNhILUCsOzRmsTmSQ17jIuqopAentWoehktxGd9e/hbIXq980/1QJg==",
      "license": "MIT"
    },
    "node_modules/lodash.isinteger": {
      "version": "4.0.4",
      "resolved": "https://registry.npmjs.org/lodash.isinteger/-/lodash.isinteger-4.0.4.tgz",
      "integrity": "sha512-DBwtEWN2caHQ9/imiNeEA5ys1JoRtRfY3d7V9wkqtbycnAmTvRRmbHKDV4a0EYc678/dia0jrte4tjYwVBaZUA==",
      "license": "MIT"
    },
    "node_modules/lodash.isnumber": {
      "version": "3.0.3",
      "resolved": "https://registry.npmjs.org/lodash.isnumber/-/lodash.isnumber-3.0.3.tgz",
      "integrity": "sha512-QYqzpfwO3/CWf3XP+Z+tkQsfaLL/EnUlXWVkIk5FUPc4sBdTehEqZONuyRt2P67PXAk+NXmTBcc97zw9t1FQrw==",
      "license": "MIT"
    },
    "node_modules/lodash.isplainobject": {
      "version": "4.0.6",
      "resolved": "https://registry.npmjs.org/lodash.isplainobject/-/lodash.isplainobject-4.0.6.tgz",
      "integrity": "sha512-oSXzaWypCMHkPC3NvBEaPHf0KsA5mvPrOPgQWDsbg8n7orZ290M0BmC/jgRZ4vcJ6DTAhjrsSYgdsW/F+MFOBA==",
      "license": "MIT"
    },
    "node_modules/lodash.isstring": {
      "version": "4.0.1",
      "resolved": "https://registry.npmjs.org/lodash.isstring/-/lodash.isstring-4.0.1.tgz",
      "integrity": "sha512-0wJxfxH1wgO3GrbuP+dTTk7op+6L41QCXbGINEmD+ny/G/eCqGzxyCsh7159S+mgDDcoarnBw6PC1PS5+wUGgw==",
      "license": "MIT"
    },
    "node_modules/lodash.once": {
      "version": "4.1.1",
      "resolved": "https://registry.npmjs.org/lodash.once/-/lodash.once-4.1.1.tgz",
      "integrity": "sha512-Sb487aTOCr9drQVL8pIxOzVhafOjZN9UU54hiN8PU3uAiSV7lx1yYNpbNmex2PK6dSJoNTSJUUswT651yww3Mg==",
      "license": "MIT"
    },
    "node_modules/loose-envify": {
      "version": "1.4.0",
      "resolved": "https://registry.npmjs.org/loose-envify/-/loose-envify-1.4.0.tgz",
      "integrity": "sha512-lyuxPGr/Wfhrlem2CL/UcnUc1zcqKAImBDzukY7Y5F/yQiNdko6+fRLevlw1HgMySw7f611UIY408EtxRSoK3Q==",
      "license": "MIT",
      "peer": true,
      "dependencies": {
        "js-tokens": "^3.0.0 || ^4.0.0"
      },
      "bin": {
        "loose-envify": "cli.js"
      }
    },
    "node_modules/lower-case": {
      "version": "2.0.2",
      "resolved": "https://registry.npmjs.org/lower-case/-/lower-case-2.0.2.tgz",
      "integrity": "sha512-7fm3l3NAF9WfN6W3JOmf5drwpVqX78JtoGJ3A6W0a6ZnldM41w2fV5D490psKFTpMds8TJse/eHLFFsNHHjHgg==",
      "license": "MIT",
      "dependencies": {
        "tslib": "^2.0.3"
      }
    },
    "node_modules/map-obj": {
      "version": "4.3.0",
      "resolved": "https://registry.npmjs.org/map-obj/-/map-obj-4.3.0.tgz",
      "integrity": "sha512-hdN1wVrZbb29eBGiGjJbeP8JbKjq1urkHJ/LIP/NY48MZ1QVXUsQBV1G1zvYFHn1XE06cwjBsOI2K3Ulnj1YXQ==",
      "license": "MIT",
      "engines": {
        "node": ">=8"
      },
      "funding": {
        "url": "https://github.com/sponsors/sindresorhus"
      }
    },
    "node_modules/math-intrinsics": {
      "version": "1.1.0",
      "resolved": "https://registry.npmjs.org/math-intrinsics/-/math-intrinsics-1.1.0.tgz",
      "integrity": "sha512-/IXtbwEk5HTPyEwyKX6hGkYXxM9nbj64B+ilVJnC/R6B0pH5G4V3b0pVbL7DBj4tkhBAppbQUlf6F6Xl9LHu1g==",
      "license": "MIT",
      "engines": {
        "node": ">= 0.4"
      }
    },
    "node_modules/media-typer": {
      "version": "0.3.0",
      "resolved": "https://registry.npmjs.org/media-typer/-/media-typer-0.3.0.tgz",
      "integrity": "sha512-dq+qelQ9akHpcOl/gUVRTxVIOkAJ1wR3QAvb4RsVjS8oVoFjDGTc679wJYmUmknUF5HwMLOgb5O+a3KxfWapPQ==",
      "license": "MIT",
      "engines": {
        "node": ">= 0.6"
      }
    },
    "node_modules/memory-pager": {
      "version": "1.5.0",
      "resolved": "https://registry.npmjs.org/memory-pager/-/memory-pager-1.5.0.tgz",
      "integrity": "sha512-ZS4Bp4r/Zoeq6+NLJpP+0Zzm0pR8whtGPf1XExKLJBAczGMnSi3It14OiNCStjQjM6NU1okjQGSxgEZN8eBYKg==",
      "license": "MIT"
    },
    "node_modules/merge-descriptors": {
      "version": "1.0.3",
      "resolved": "https://registry.npmjs.org/merge-descriptors/-/merge-descriptors-1.0.3.tgz",
      "integrity": "sha512-gaNvAS7TZ897/rVaZ0nMtAyxNyi/pdbjbAwUpFQpN70GqnVfOiXpeUUMKRBmzXaSQ8DdTX4/0ms62r2K+hE6mQ==",
      "license": "MIT",
      "funding": {
        "url": "https://github.com/sponsors/sindresorhus"
      }
    },
    "node_modules/methods": {
      "version": "1.1.2",
      "resolved": "https://registry.npmjs.org/methods/-/methods-1.1.2.tgz",
      "integrity": "sha512-iclAHeNqNm68zFtnZ0e+1L2yUIdvzNoauKU4WBA3VvH/vPFieF7qfRlwUZU+DA9P9bPXIS90ulxoUoCH23sV2w==",
      "license": "MIT",
      "engines": {
        "node": ">= 0.6"
      }
    },
    "node_modules/mime": {
      "version": "1.6.0",
      "resolved": "https://registry.npmjs.org/mime/-/mime-1.6.0.tgz",
      "integrity": "sha512-x0Vn8spI+wuJ1O6S7gnbaQg8Pxh4NNHb7KSINmEWKiPE4RKOplvijn+NkmYmmRgP68mc70j2EbeTFRsrswaQeg==",
      "license": "MIT",
      "bin": {
        "mime": "cli.js"
      },
      "engines": {
        "node": ">=4"
      }
    },
    "node_modules/mime-db": {
      "version": "1.52.0",
      "resolved": "https://registry.npmjs.org/mime-db/-/mime-db-1.52.0.tgz",
      "integrity": "sha512-sPU4uV7dYlvtWJxwwxHD0PuihVNiE7TyAbQ5SWxDCB9mUYvOgroQOwYQQOKPJ8CIbE+1ETVlOoK1UC2nU3gYvg==",
      "license": "MIT",
      "engines": {
        "node": ">= 0.6"
      }
    },
    "node_modules/mime-types": {
      "version": "2.1.35",
      "resolved": "https://registry.npmjs.org/mime-types/-/mime-types-2.1.35.tgz",
      "integrity": "sha512-ZDY+bPm5zTTF+YpCrAU9nK0UgICYPT0QtT1NZWFv4s++TNkcgVaT0g6+4R2uI4MjQjzysHB1zxuWL50hzaeXiw==",
      "license": "MIT",
      "dependencies": {
        "mime-db": "1.52.0"
      },
      "engines": {
        "node": ">= 0.6"
      }
    },
    "node_modules/minimatch": {
      "version": "3.1.2",
      "resolved": "https://registry.npmjs.org/minimatch/-/minimatch-3.1.2.tgz",
      "integrity": "sha512-J7p63hRiAjw1NDEww1W7i37+ByIrOWO5XQQAzZ3VOcL0PNybwpfmV/N05zFAzwQ9USyEcX6t3UO+K5aqBQOIHw==",
      "license": "ISC",
      "dependencies": {
        "brace-expansion": "^1.1.7"
      },
      "engines": {
        "node": "*"
      }
    },
    "node_modules/mongodb": {
      "version": "6.15.0",
      "resolved": "https://registry.npmjs.org/mongodb/-/mongodb-6.15.0.tgz",
      "integrity": "sha512-ifBhQ0rRzHDzqp9jAQP6OwHSH7dbYIQjD3SbJs9YYk9AikKEettW/9s/tbSFDTpXcRbF+u1aLrhHxDFaYtZpFQ==",
      "license": "Apache-2.0",
      "dependencies": {
        "@mongodb-js/saslprep": "^1.1.9",
        "bson": "^6.10.3",
        "mongodb-connection-string-url": "^3.0.0"
      },
      "engines": {
        "node": ">=16.20.1"
      },
      "peerDependencies": {
        "@aws-sdk/credential-providers": "^3.188.0",
        "@mongodb-js/zstd": "^1.1.0 || ^2.0.0",
        "gcp-metadata": "^5.2.0",
        "kerberos": "^2.0.1",
        "mongodb-client-encryption": ">=6.0.0 <7",
        "snappy": "^7.2.2",
        "socks": "^2.7.1"
      },
      "peerDependenciesMeta": {
        "@aws-sdk/credential-providers": {
          "optional": true
        },
        "@mongodb-js/zstd": {
          "optional": true
        },
        "gcp-metadata": {
          "optional": true
        },
        "kerberos": {
          "optional": true
        },
        "mongodb-client-encryption": {
          "optional": true
        },
        "snappy": {
          "optional": true
        },
        "socks": {
          "optional": true
        }
      }
    },
    "node_modules/mongodb-connection-string-url": {
      "version": "3.0.2",
      "resolved": "https://registry.npmjs.org/mongodb-connection-string-url/-/mongodb-connection-string-url-3.0.2.tgz",
      "integrity": "sha512-rMO7CGo/9BFwyZABcKAWL8UJwH/Kc2x0g72uhDWzG48URRax5TCIcJ7Rc3RZqffZzO/Gwff/jyKwCU9TN8gehA==",
      "license": "Apache-2.0",
      "dependencies": {
        "@types/whatwg-url": "^11.0.2",
        "whatwg-url": "^14.1.0 || ^13.0.0"
      }
    },
    "node_modules/mongoose": {
      "version": "8.13.0",
      "resolved": "https://registry.npmjs.org/mongoose/-/mongoose-8.13.0.tgz",
      "integrity": "sha512-e/iYV1mPeOkg+SWAMHzt3t42/EZyER3OB1H2pjP9C3vQ+Qb5DMeV9Kb+YCUycKgScA3fbwL7dKG4EpinGlg21g==",
      "license": "MIT",
      "dependencies": {
        "bson": "^6.10.3",
        "kareem": "2.6.3",
        "mongodb": "~6.15.0",
        "mpath": "0.9.0",
        "mquery": "5.0.0",
        "ms": "2.1.3",
        "sift": "17.1.3"
      },
      "engines": {
        "node": ">=16.20.1"
      },
      "funding": {
        "type": "opencollective",
        "url": "https://opencollective.com/mongoose"
      }
    },
    "node_modules/mongoose/node_modules/ms": {
      "version": "2.1.3",
      "resolved": "https://registry.npmjs.org/ms/-/ms-2.1.3.tgz",
      "integrity": "sha512-6FlzubTLZG3J2a/NVCAleEhjzq5oxgHyaCU9yYXvcLsvoVaHJq/s5xXI6/XXP6tz7R9xAOtHnSO/tXtF3WRTlA==",
      "license": "MIT"
    },
    "node_modules/mpath": {
      "version": "0.9.0",
      "resolved": "https://registry.npmjs.org/mpath/-/mpath-0.9.0.tgz",
      "integrity": "sha512-ikJRQTk8hw5DEoFVxHG1Gn9T/xcjtdnOKIU1JTmGjZZlg9LST2mBLmcX3/ICIbgJydT2GOc15RnNy5mHmzfSew==",
      "license": "MIT",
      "engines": {
        "node": ">=4.0.0"
      }
    },
    "node_modules/mquery": {
      "version": "5.0.0",
      "resolved": "https://registry.npmjs.org/mquery/-/mquery-5.0.0.tgz",
      "integrity": "sha512-iQMncpmEK8R8ncT8HJGsGc9Dsp8xcgYMVSbs5jgnm1lFHTZqMJTUWTDx1LBO8+mK3tPNZWFLBghQEIOULSTHZg==",
      "license": "MIT",
      "dependencies": {
        "debug": "4.x"
      },
      "engines": {
        "node": ">=14.0.0"
      }
    },
    "node_modules/mquery/node_modules/debug": {
      "version": "4.4.0",
      "resolved": "https://registry.npmjs.org/debug/-/debug-4.4.0.tgz",
      "integrity": "sha512-6WTZ/IxCY/T6BALoZHaE4ctp9xm+Z5kY/pzYaCHRFeyVhojxlrm+46y68HA6hr0TcwEssoxNiDEUJQjfPZ/RYA==",
      "license": "MIT",
      "dependencies": {
        "ms": "^2.1.3"
      },
      "engines": {
        "node": ">=6.0"
      },
      "peerDependenciesMeta": {
        "supports-color": {
          "optional": true
        }
      }
    },
    "node_modules/mquery/node_modules/ms": {
      "version": "2.1.3",
      "resolved": "https://registry.npmjs.org/ms/-/ms-2.1.3.tgz",
      "integrity": "sha512-6FlzubTLZG3J2a/NVCAleEhjzq5oxgHyaCU9yYXvcLsvoVaHJq/s5xXI6/XXP6tz7R9xAOtHnSO/tXtF3WRTlA==",
      "license": "MIT"
    },
    "node_modules/ms": {
      "version": "2.0.0",
      "resolved": "https://registry.npmjs.org/ms/-/ms-2.0.0.tgz",
      "integrity": "sha512-Tpp60P6IUJDTuOq/5Z8cdskzJujfwqfOTkrwIwj7IRISpnkJnT6SyJ4PCPnGMoFjC9ddhal5KVIYtAt97ix05A==",
      "license": "MIT"
    },
    "node_modules/negotiator": {
      "version": "0.6.3",
      "resolved": "https://registry.npmjs.org/negotiator/-/negotiator-0.6.3.tgz",
      "integrity": "sha512-+EUsqGPLsM+j/zdChZjsnX51g4XrHFOIXwfnCVPGlQk/k5giakcKsuxCObBRu6DSm9opw/O6slWbJdghQM4bBg==",
      "license": "MIT",
      "engines": {
        "node": ">= 0.6"
      }
    },
    "node_modules/no-case": {
      "version": "3.0.4",
      "resolved": "https://registry.npmjs.org/no-case/-/no-case-3.0.4.tgz",
      "integrity": "sha512-fgAN3jGAh+RoxUGZHTSOLJIqUc2wmoBwGR4tbpNAKmmovFoWq0OdRkb0VkldReO2a2iBT/OEulG9XSUc10r3zg==",
      "license": "MIT",
      "dependencies": {
        "lower-case": "^2.0.2",
        "tslib": "^2.0.3"
      }
    },
    "node_modules/node-fetch-native": {
      "version": "1.0.1",
      "resolved": "https://registry.npmjs.org/node-fetch-native/-/node-fetch-native-1.0.1.tgz",
      "integrity": "sha512-VzW+TAk2wE4X9maiKMlT+GsPU4OMmR1U9CrHSmd3DFLn2IcZ9VJ6M6BBugGfYUnPCLSYxXdZy17M0BEJyhUTwg==",
      "license": "MIT"
    },
    "node_modules/nodemon": {
      "version": "3.1.9",
      "resolved": "https://registry.npmjs.org/nodemon/-/nodemon-3.1.9.tgz",
      "integrity": "sha512-hdr1oIb2p6ZSxu3PB2JWWYS7ZQ0qvaZsc3hK8DR8f02kRzc8rjYmxAIvdz+aYC+8F2IjNaB7HMcSDg8nQpJxyg==",
      "license": "MIT",
      "dependencies": {
        "chokidar": "^3.5.2",
        "debug": "^4",
        "ignore-by-default": "^1.0.1",
        "minimatch": "^3.1.2",
        "pstree.remy": "^1.1.8",
        "semver": "^7.5.3",
        "simple-update-notifier": "^2.0.0",
        "supports-color": "^5.5.0",
        "touch": "^3.1.0",
        "undefsafe": "^2.0.5"
      },
      "bin": {
        "nodemon": "bin/nodemon.js"
      },
      "engines": {
        "node": ">=10"
      },
      "funding": {
        "type": "opencollective",
        "url": "https://opencollective.com/nodemon"
      }
    },
    "node_modules/nodemon/node_modules/debug": {
      "version": "4.4.0",
      "resolved": "https://registry.npmjs.org/debug/-/debug-4.4.0.tgz",
      "integrity": "sha512-6WTZ/IxCY/T6BALoZHaE4ctp9xm+Z5kY/pzYaCHRFeyVhojxlrm+46y68HA6hr0TcwEssoxNiDEUJQjfPZ/RYA==",
      "license": "MIT",
      "dependencies": {
        "ms": "^2.1.3"
      },
      "engines": {
        "node": ">=6.0"
      },
      "peerDependenciesMeta": {
        "supports-color": {
          "optional": true
        }
      }
    },
    "node_modules/nodemon/node_modules/ms": {
      "version": "2.1.3",
      "resolved": "https://registry.npmjs.org/ms/-/ms-2.1.3.tgz",
      "integrity": "sha512-6FlzubTLZG3J2a/NVCAleEhjzq5oxgHyaCU9yYXvcLsvoVaHJq/s5xXI6/XXP6tz7R9xAOtHnSO/tXtF3WRTlA==",
      "license": "MIT"
    },
    "node_modules/normalize-path": {
      "version": "3.0.0",
      "resolved": "https://registry.npmjs.org/normalize-path/-/normalize-path-3.0.0.tgz",
      "integrity": "sha512-6eZs5Ls3WtCisHWp9S2GUy8dqkpGi4BVSz3GaqiE6ezub0512ESztXUwUB6C6IKbQkY2Pnb/mD4WYojCRwcwLA==",
      "license": "MIT",
      "engines": {
        "node": ">=0.10.0"
      }
    },
    "node_modules/object-assign": {
      "version": "4.1.1",
      "resolved": "https://registry.npmjs.org/object-assign/-/object-assign-4.1.1.tgz",
      "integrity": "sha512-rJgTQnkUnH1sFw8yT6VSU3zD3sWmu6sZhIseY8VX+GRu3P6F7Fu+JNDoXfklElbLJSnc3FUQHVe4cU5hj+BcUg==",
      "license": "MIT",
      "engines": {
        "node": ">=0.10.0"
      }
    },
    "node_modules/object-inspect": {
      "version": "1.13.4",
      "resolved": "https://registry.npmjs.org/object-inspect/-/object-inspect-1.13.4.tgz",
      "integrity": "sha512-W67iLl4J2EXEGTbfeHCffrjDfitvLANg0UlX3wFUUSTx92KXRFegMHUVgSqE+wvhAbi4WqjGg9czysTV2Epbew==",
      "license": "MIT",
      "engines": {
        "node": ">= 0.4"
      },
      "funding": {
        "url": "https://github.com/sponsors/ljharb"
      }
    },
    "node_modules/on-finished": {
      "version": "2.4.1",
      "resolved": "https://registry.npmjs.org/on-finished/-/on-finished-2.4.1.tgz",
      "integrity": "sha512-oVlzkg3ENAhCk2zdv7IJwd/QUD4z2RxRwpkcGY8psCVcCYZNq4wYnVWALHM+brtuJjePWiYF/ClmuDr8Ch5+kg==",
      "license": "MIT",
      "dependencies": {
        "ee-first": "1.1.1"
      },
      "engines": {
        "node": ">= 0.8"
      }
    },
    "node_modules/parseurl": {
      "version": "1.3.3",
      "resolved": "https://registry.npmjs.org/parseurl/-/parseurl-1.3.3.tgz",
      "integrity": "sha512-CiyeOxFT/JZyN5m0z9PfXw4SCBJ6Sygz1Dpl0wqjlhDEGGBP1GnsUVEL0p63hoG1fcj3fHynXi9NYO4nWOL+qQ==",
      "license": "MIT",
      "engines": {
        "node": ">= 0.8"
      }
    },
    "node_modules/path-to-regexp": {
      "version": "0.1.12",
      "resolved": "https://registry.npmjs.org/path-to-regexp/-/path-to-regexp-0.1.12.tgz",
      "integrity": "sha512-RA1GjUVMnvYFxuqovrEqZoxxW5NUZqbwKtYz/Tt7nXerk0LbLblQmrsgdeOxV5SFHf0UDggjS/bSeOZwt1pmEQ==",
      "license": "MIT"
    },
    "node_modules/picomatch": {
      "version": "2.3.1",
      "resolved": "https://registry.npmjs.org/picomatch/-/picomatch-2.3.1.tgz",
      "integrity": "sha512-JU3teHTNjmE2VCGFzuY8EXzCDVwEqB2a8fsIvwaStHhAWJEeVd1o1QD80CU6+ZdEXXSLbSsuLwJjkCBWqRQUVA==",
      "license": "MIT",
      "engines": {
        "node": ">=8.6"
      },
      "funding": {
        "url": "https://github.com/sponsors/jonschlinkert"
      }
    },
    "node_modules/proxy-addr": {
      "version": "2.0.7",
      "resolved": "https://registry.npmjs.org/proxy-addr/-/proxy-addr-2.0.7.tgz",
      "integrity": "sha512-llQsMLSUDUPT44jdrU/O37qlnifitDP+ZwrmmZcoSKyLKvtZxpyV0n2/bD/N4tBAAZ/gJEdZU7KMraoK1+XYAg==",
      "license": "MIT",
      "dependencies": {
        "forwarded": "0.2.0",
        "ipaddr.js": "1.9.1"
      },
      "engines": {
        "node": ">= 0.10"
      }
    },
    "node_modules/pstree.remy": {
      "version": "1.1.8",
      "resolved": "https://registry.npmjs.org/pstree.remy/-/pstree.remy-1.1.8.tgz",
      "integrity": "sha512-77DZwxQmxKnu3aR542U+X8FypNzbfJ+C5XQDk3uWjWxn6151aIMGthWYRXTqT1E5oJvg+ljaa2OJi+VfvCOQ8w==",
      "license": "MIT"
    },
    "node_modules/punycode": {
      "version": "2.3.1",
      "resolved": "https://registry.npmjs.org/punycode/-/punycode-2.3.1.tgz",
      "integrity": "sha512-vYt7UD1U9Wg6138shLtLOvdAu+8DsC/ilFtEVHcH+wydcSpNE20AfSOduf6MkRFahL5FY7X1oU7nKVZFtfq8Fg==",
      "license": "MIT",
      "engines": {
        "node": ">=6"
      }
    },
    "node_modules/pvtsutils": {
      "version": "1.3.6",
      "resolved": "https://registry.npmjs.org/pvtsutils/-/pvtsutils-1.3.6.tgz",
      "integrity": "sha512-PLgQXQ6H2FWCaeRak8vvk1GW462lMxB5s3Jm673N82zI4vqtVUPuZdffdZbPDFRoU8kAhItWFtPCWiPpp4/EDg==",
      "license": "MIT",
      "dependencies": {
        "tslib": "^2.8.1"
      }
    },
    "node_modules/pvtsutils/node_modules/tslib": {
      "version": "2.8.1",
      "resolved": "https://registry.npmjs.org/tslib/-/tslib-2.8.1.tgz",
      "integrity": "sha512-oJFu94HQb+KVduSUQL7wnpmqnfmLsOA/nAh6b6EH0wCEoK0/mPeXU6c3wKDV83MkOuHPRHtSXKKU99IBazS/2w==",
      "license": "0BSD"
    },
    "node_modules/pvutils": {
      "version": "1.1.3",
      "resolved": "https://registry.npmjs.org/pvutils/-/pvutils-1.1.3.tgz",
      "integrity": "sha512-pMpnA0qRdFp32b1sJl1wOJNxZLQ2cbQx+k6tjNtZ8CpvVhNqEPRgivZ2WOUev2YMajecdH7ctUPDvEe87nariQ==",
      "license": "MIT",
      "engines": {
        "node": ">=6.0.0"
      }
    },
    "node_modules/qs": {
      "version": "6.13.0",
      "resolved": "https://registry.npmjs.org/qs/-/qs-6.13.0.tgz",
      "integrity": "sha512-+38qI9SOr8tfZ4QmJNplMUxqjbe7LKvvZgWdExBOmd+egZTtjLB67Gu0HRX3u/XOq7UU2Nx6nsjvS16Z9uwfpg==",
      "license": "BSD-3-Clause",
      "dependencies": {
        "side-channel": "^1.0.6"
      },
      "engines": {
        "node": ">=0.6"
      },
      "funding": {
        "url": "https://github.com/sponsors/ljharb"
      }
    },
    "node_modules/quick-lru": {
      "version": "4.0.1",
      "resolved": "https://registry.npmjs.org/quick-lru/-/quick-lru-4.0.1.tgz",
      "integrity": "sha512-ARhCpm70fzdcvNQfPoy49IaanKkTlRWF2JMzqhcJbhSFRZv7nPTvZJdcY7301IPmvW+/p0RgIWnQDLJxifsQ7g==",
      "license": "MIT",
      "engines": {
        "node": ">=8"
      }
    },
    "node_modules/range-parser": {
      "version": "1.2.1",
      "resolved": "https://registry.npmjs.org/range-parser/-/range-parser-1.2.1.tgz",
      "integrity": "sha512-Hrgsx+orqoygnmhFbKaHE6c296J+HTAQXoxEF6gNupROmmGJRoyzfG3ccAveqCBrwr/2yxQ5BVd/GTl5agOwSg==",
      "license": "MIT",
      "engines": {
        "node": ">= 0.6"
      }
    },
    "node_modules/raw-body": {
      "version": "2.5.2",
      "resolved": "https://registry.npmjs.org/raw-body/-/raw-body-2.5.2.tgz",
      "integrity": "sha512-8zGqypfENjCIqGhgXToC8aB2r7YrBX+AQAfIPs/Mlk+BtPTztOvTS01NRW/3Eh60J+a48lt8qsCzirQ6loCVfA==",
      "license": "MIT",
      "dependencies": {
        "bytes": "3.1.2",
        "http-errors": "2.0.0",
        "iconv-lite": "0.4.24",
        "unpipe": "1.0.0"
      },
      "engines": {
        "node": ">= 0.8"
      }
    },
    "node_modules/react": {
      "version": "18.3.1",
      "resolved": "https://registry.npmjs.org/react/-/react-18.3.1.tgz",
      "integrity": "sha512-wS+hAgJShR0KhEvPJArfuPVN1+Hz1t0Y6n5jLrGQbkb4urgPE/0Rve+1kMB1v/oWgHgm4WIcV+i7F2pTVj+2iQ==",
      "license": "MIT",
      "peer": true,
      "dependencies": {
        "loose-envify": "^1.1.0"
      },
      "engines": {
        "node": ">=0.10.0"
      }
    },
    "node_modules/readdirp": {
      "version": "3.6.0",
      "resolved": "https://registry.npmjs.org/readdirp/-/readdirp-3.6.0.tgz",
      "integrity": "sha512-hOS089on8RduqdbhvQ5Z37A0ESjsqz6qnRcffsMU3495FuTdqSm+7bhJ29JvIOsBDEEnan5DPu9t3To9VRlMzA==",
      "license": "MIT",
      "dependencies": {
        "picomatch": "^2.2.1"
      },
      "engines": {
        "node": ">=8.10.0"
      }
    },
    "node_modules/safe-buffer": {
      "version": "5.2.1",
      "resolved": "https://registry.npmjs.org/safe-buffer/-/safe-buffer-5.2.1.tgz",
      "integrity": "sha512-rp3So07KcdmmKbGvgaNxQSJr7bGVSVk5S9Eq1F+ppbRo70+YeaDxkw5Dd8NPN+GD6bjnYm2VuPuCXmpuYvmCXQ==",
      "funding": [
        {
          "type": "github",
          "url": "https://github.com/sponsors/feross"
        },
        {
          "type": "patreon",
          "url": "https://www.patreon.com/feross"
        },
        {
          "type": "consulting",
          "url": "https://feross.org/support"
        }
      ],
      "license": "MIT"
    },
    "node_modules/safer-buffer": {
      "version": "2.1.2",
      "resolved": "https://registry.npmjs.org/safer-buffer/-/safer-buffer-2.1.2.tgz",
      "integrity": "sha512-YZo3K82SD7Riyi0E1EQPojLz7kpepnSQI9IyPbHHg1XXXevb5dJI7tpyN2ADxGcQbHG7vcyRHk0cbwqcQriUtg==",
      "license": "MIT"
    },
    "node_modules/semver": {
      "version": "7.7.1",
      "resolved": "https://registry.npmjs.org/semver/-/semver-7.7.1.tgz",
      "integrity": "sha512-hlq8tAfn0m/61p4BVRcPzIGr6LKiMwo4VM6dGi6pt4qcRkmNzTcWq6eCEjEh+qXjkMDvPlOFFSGwQjoEa6gyMA==",
      "license": "ISC",
      "bin": {
        "semver": "bin/semver.js"
      },
      "engines": {
        "node": ">=10"
      }
    },
    "node_modules/send": {
      "version": "0.19.0",
      "resolved": "https://registry.npmjs.org/send/-/send-0.19.0.tgz",
      "integrity": "sha512-dW41u5VfLXu8SJh5bwRmyYUbAoSB3c9uQh6L8h/KtsFREPWpbX1lrljJo186Jc4nmci/sGUZ9a0a0J2zgfq2hw==",
      "license": "MIT",
      "dependencies": {
        "debug": "2.6.9",
        "depd": "2.0.0",
        "destroy": "1.2.0",
        "encodeurl": "~1.0.2",
        "escape-html": "~1.0.3",
        "etag": "~1.8.1",
        "fresh": "0.5.2",
        "http-errors": "2.0.0",
        "mime": "1.6.0",
        "ms": "2.1.3",
        "on-finished": "2.4.1",
        "range-parser": "~1.2.1",
        "statuses": "2.0.1"
      },
      "engines": {
        "node": ">= 0.8.0"
      }
    },
    "node_modules/send/node_modules/encodeurl": {
      "version": "1.0.2",
      "resolved": "https://registry.npmjs.org/encodeurl/-/encodeurl-1.0.2.tgz",
      "integrity": "sha512-TPJXq8JqFaVYm2CWmPvnP2Iyo4ZSM7/QKcSmuMLDObfpH5fi7RUGmd/rTDf+rut/saiDiQEeVTNgAmJEdAOx0w==",
      "license": "MIT",
      "engines": {
        "node": ">= 0.8"
      }
    },
    "node_modules/send/node_modules/ms": {
      "version": "2.1.3",
      "resolved": "https://registry.npmjs.org/ms/-/ms-2.1.3.tgz",
      "integrity": "sha512-6FlzubTLZG3J2a/NVCAleEhjzq5oxgHyaCU9yYXvcLsvoVaHJq/s5xXI6/XXP6tz7R9xAOtHnSO/tXtF3WRTlA==",
      "license": "MIT"
    },
    "node_modules/serve-static": {
      "version": "1.16.2",
      "resolved": "https://registry.npmjs.org/serve-static/-/serve-static-1.16.2.tgz",
      "integrity": "sha512-VqpjJZKadQB/PEbEwvFdO43Ax5dFBZ2UECszz8bQ7pi7wt//PWe1P6MN7eCnjsatYtBT6EuiClbjSWP2WrIoTw==",
      "license": "MIT",
      "dependencies": {
        "encodeurl": "~2.0.0",
        "escape-html": "~1.0.3",
        "parseurl": "~1.3.3",
        "send": "0.19.0"
      },
      "engines": {
        "node": ">= 0.8.0"
      }
    },
    "node_modules/setprototypeof": {
      "version": "1.2.0",
      "resolved": "https://registry.npmjs.org/setprototypeof/-/setprototypeof-1.2.0.tgz",
      "integrity": "sha512-E5LDX7Wrp85Kil5bhZv46j8jOeboKq5JMmYM3gVGdGH8xFpPWXUMsNrlODCrkoxMEeNi/XZIwuRvY4XNwYMJpw==",
      "license": "ISC"
    },
    "node_modules/side-channel": {
      "version": "1.1.0",
      "resolved": "https://registry.npmjs.org/side-channel/-/side-channel-1.1.0.tgz",
      "integrity": "sha512-ZX99e6tRweoUXqR+VBrslhda51Nh5MTQwou5tnUDgbtyM0dBgmhEDtWGP/xbKn6hqfPRHujUNwz5fy/wbbhnpw==",
      "license": "MIT",
      "dependencies": {
        "es-errors": "^1.3.0",
        "object-inspect": "^1.13.3",
        "side-channel-list": "^1.0.0",
        "side-channel-map": "^1.0.1",
        "side-channel-weakmap": "^1.0.2"
      },
      "engines": {
        "node": ">= 0.4"
      },
      "funding": {
        "url": "https://github.com/sponsors/ljharb"
      }
    },
    "node_modules/side-channel-list": {
      "version": "1.0.0",
      "resolved": "https://registry.npmjs.org/side-channel-list/-/side-channel-list-1.0.0.tgz",
      "integrity": "sha512-FCLHtRD/gnpCiCHEiJLOwdmFP+wzCmDEkc9y7NsYxeF4u7Btsn1ZuwgwJGxImImHicJArLP4R0yX4c2KCrMrTA==",
      "license": "MIT",
      "dependencies": {
        "es-errors": "^1.3.0",
        "object-inspect": "^1.13.3"
      },
      "engines": {
        "node": ">= 0.4"
      },
      "funding": {
        "url": "https://github.com/sponsors/ljharb"
      }
    },
    "node_modules/side-channel-map": {
      "version": "1.0.1",
      "resolved": "https://registry.npmjs.org/side-channel-map/-/side-channel-map-1.0.1.tgz",
      "integrity": "sha512-VCjCNfgMsby3tTdo02nbjtM/ewra6jPHmpThenkTYh8pG9ucZ/1P8So4u4FGBek/BjpOVsDCMoLA/iuBKIFXRA==",
      "license": "MIT",
      "dependencies": {
        "call-bound": "^1.0.2",
        "es-errors": "^1.3.0",
        "get-intrinsic": "^1.2.5",
        "object-inspect": "^1.13.3"
      },
      "engines": {
        "node": ">= 0.4"
      },
      "funding": {
        "url": "https://github.com/sponsors/ljharb"
      }
    },
    "node_modules/side-channel-weakmap": {
      "version": "1.0.2",
      "resolved": "https://registry.npmjs.org/side-channel-weakmap/-/side-channel-weakmap-1.0.2.tgz",
      "integrity": "sha512-WPS/HvHQTYnHisLo9McqBHOJk2FkHO/tlpvldyrnem4aeQp4hai3gythswg6p01oSoTl58rcpiFAjF2br2Ak2A==",
      "license": "MIT",
      "dependencies": {
        "call-bound": "^1.0.2",
        "es-errors": "^1.3.0",
        "get-intrinsic": "^1.2.5",
        "object-inspect": "^1.13.3",
        "side-channel-map": "^1.0.1"
      },
      "engines": {
        "node": ">= 0.4"
      },
      "funding": {
        "url": "https://github.com/sponsors/ljharb"
      }
    },
    "node_modules/sift": {
      "version": "17.1.3",
      "resolved": "https://registry.npmjs.org/sift/-/sift-17.1.3.tgz",
      "integrity": "sha512-Rtlj66/b0ICeFzYTuNvX/EF1igRbbnGSvEyT79McoZa/DeGhMyC5pWKOEsZKnpkqtSeovd5FL/bjHWC3CIIvCQ==",
      "license": "MIT"
    },
    "node_modules/simple-update-notifier": {
      "version": "2.0.0",
      "resolved": "https://registry.npmjs.org/simple-update-notifier/-/simple-update-notifier-2.0.0.tgz",
      "integrity": "sha512-a2B9Y0KlNXl9u/vsW6sTIu9vGEpfKu2wRV6l1H3XEas/0gUIzGzBoP/IouTcUQbm9JWZLH3COxyn03TYlFax6w==",
      "license": "MIT",
      "dependencies": {
        "semver": "^7.5.3"
      },
      "engines": {
        "node": ">=10"
      }
    },
    "node_modules/snake-case": {
      "version": "3.0.4",
      "resolved": "https://registry.npmjs.org/snake-case/-/snake-case-3.0.4.tgz",
      "integrity": "sha512-LAOh4z89bGQvl9pFfNF8V146i7o7/CqFPbqzYgP+yYzDIDeS9HaNFtXABamRW+AQzEVODcvE79ljJ+8a9YSdMg==",
      "license": "MIT",
      "dependencies": {
        "dot-case": "^3.0.4",
        "tslib": "^2.0.3"
      }
    },
    "node_modules/snakecase-keys": {
      "version": "3.2.1",
      "resolved": "https://registry.npmjs.org/snakecase-keys/-/snakecase-keys-3.2.1.tgz",
      "integrity": "sha512-CjU5pyRfwOtaOITYv5C8DzpZ8XA/ieRsDpr93HI2r6e3YInC6moZpSQbmUtg8cTk58tq2x3jcG2gv+p1IZGmMA==",
      "license": "MIT",
      "dependencies": {
        "map-obj": "^4.1.0",
        "to-snake-case": "^1.0.0"
      },
      "engines": {
        "node": ">=8"
      }
    },
    "node_modules/sparse-bitfield": {
      "version": "3.0.3",
      "resolved": "https://registry.npmjs.org/sparse-bitfield/-/sparse-bitfield-3.0.3.tgz",
      "integrity": "sha512-kvzhi7vqKTfkh0PZU+2D2PIllw2ymqJKujUcyPMd9Y75Nv4nPbGJZXNhxsgdQab2BmlDct1YnfQCguEvHr7VsQ==",
      "license": "MIT",
      "dependencies": {
        "memory-pager": "^1.0.2"
      }
    },
    "node_modules/statuses": {
      "version": "2.0.1",
      "resolved": "https://registry.npmjs.org/statuses/-/statuses-2.0.1.tgz",
      "integrity": "sha512-RwNA9Z/7PrK06rYLIzFMlaF+l73iwpzsqRIFgbMLbTcLD6cOao82TaWefPXQvB2fOC4AjuYSEndS7N/mTCbkdQ==",
      "license": "MIT",
      "engines": {
        "node": ">= 0.8"
      }
    },
    "node_modules/supports-color": {
      "version": "5.5.0",
      "resolved": "https://registry.npmjs.org/supports-color/-/supports-color-5.5.0.tgz",
      "integrity": "sha512-QjVjwdXIt408MIiAqCX4oUKsgU2EqAGzs2Ppkm4aQYbjm+ZEWEcW4SfFNTr4uMNZma0ey4f5lgLrkB0aX0QMow==",
      "license": "MIT",
      "dependencies": {
        "has-flag": "^3.0.0"
      },
      "engines": {
        "node": ">=4"
      }
    },
    "node_modules/swr": {
      "version": "2.2.0",
      "resolved": "https://registry.npmjs.org/swr/-/swr-2.2.0.tgz",
      "integrity": "sha512-AjqHOv2lAhkuUdIiBu9xbuettzAzWXmCEcLONNKJRba87WAefz8Ca9d6ds/SzrPc235n1IxWYdhJ2zF3MNUaoQ==",
      "license": "MIT",
      "dependencies": {
        "use-sync-external-store": "^1.2.0"
      },
      "peerDependencies": {
        "react": "^16.11.0 || ^17.0.0 || ^18.0.0"
      }
    },
    "node_modules/to-no-case": {
      "version": "1.0.2",
      "resolved": "https://registry.npmjs.org/to-no-case/-/to-no-case-1.0.2.tgz",
      "integrity": "sha512-Z3g735FxuZY8rodxV4gH7LxClE4H0hTIyHNIHdk+vpQxjLm0cwnKXq/OFVZ76SOQmto7txVcwSCwkU5kqp+FKg==",
      "license": "MIT"
    },
    "node_modules/to-regex-range": {
      "version": "5.0.1",
      "resolved": "https://registry.npmjs.org/to-regex-range/-/to-regex-range-5.0.1.tgz",
      "integrity": "sha512-65P7iz6X5yEr1cwcgvQxbbIw7Uk3gOy5dIdtZ4rDveLqhrdJP+Li/Hx6tyK0NEb+2GCyneCMJiGqrADCSNk8sQ==",
      "license": "MIT",
      "dependencies": {
        "is-number": "^7.0.0"
      },
      "engines": {
        "node": ">=8.0"
      }
    },
    "node_modules/to-snake-case": {
      "version": "1.0.0",
      "resolved": "https://registry.npmjs.org/to-snake-case/-/to-snake-case-1.0.0.tgz",
      "integrity": "sha512-joRpzBAk1Bhi2eGEYBjukEWHOe/IvclOkiJl3DtA91jV6NwQ3MwXA4FHYeqk8BNp/D8bmi9tcNbRu/SozP0jbQ==",
      "license": "MIT",
      "dependencies": {
        "to-space-case": "^1.0.0"
      }
    },
    "node_modules/to-space-case": {
      "version": "1.0.0",
      "resolved": "https://registry.npmjs.org/to-space-case/-/to-space-case-1.0.0.tgz",
      "integrity": "sha512-rLdvwXZ39VOn1IxGL3V6ZstoTbwLRckQmn/U8ZDLuWwIXNpuZDhQ3AiRUlhTbOXFVE9C+dR51wM0CBDhk31VcA==",
      "license": "MIT",
      "dependencies": {
        "to-no-case": "^1.0.0"
      }
    },
    "node_modules/toidentifier": {
      "version": "1.0.1",
      "resolved": "https://registry.npmjs.org/toidentifier/-/toidentifier-1.0.1.tgz",
      "integrity": "sha512-o5sSPKEkg/DIQNmH43V0/uerLrpzVedkUh8tGNvaeXpfpuwjKenlSox/2O/BTlZUtEe+JG7s5YhEz608PlAHRA==",
      "license": "MIT",
      "engines": {
        "node": ">=0.6"
      }
    },
    "node_modules/touch": {
      "version": "3.1.1",
      "resolved": "https://registry.npmjs.org/touch/-/touch-3.1.1.tgz",
      "integrity": "sha512-r0eojU4bI8MnHr8c5bNo7lJDdI2qXlWWJk6a9EAFG7vbhTjElYhBVS3/miuE0uOuoLdb8Mc/rVfsmm6eo5o9GA==",
      "license": "ISC",
      "bin": {
        "nodetouch": "bin/nodetouch.js"
      }
    },
    "node_modules/tr46": {
      "version": "5.1.0",
      "resolved": "https://registry.npmjs.org/tr46/-/tr46-5.1.0.tgz",
      "integrity": "sha512-IUWnUK7ADYR5Sl1fZlO1INDUhVhatWl7BtJWsIhwJ0UAK7ilzzIa8uIqOO/aYVWHZPJkKbEL+362wrzoeRF7bw==",
      "license": "MIT",
      "dependencies": {
        "punycode": "^2.3.1"
      },
      "engines": {
        "node": ">=18"
      }
    },
    "node_modules/tslib": {
      "version": "2.4.1",
      "resolved": "https://registry.npmjs.org/tslib/-/tslib-2.4.1.tgz",
      "integrity": "sha512-tGyy4dAjRIEwI7BzsB0lynWgOpfqjUdq91XXAlIWD2OwKBH7oCl/GZG/HT4BOHrTlPMOASlMQ7veyTqpmRcrNA==",
      "license": "0BSD"
    },
    "node_modules/type-fest": {
      "version": "2.19.0",
      "resolved": "https://registry.npmjs.org/type-fest/-/type-fest-2.19.0.tgz",
      "integrity": "sha512-RAH822pAdBgcNMAfWnCBU3CFZcfZ/i1eZjwFU/dsLKumyuuP3niueg2UAukXYF0E2AAoc82ZSSf9J0WQBinzHA==",
      "license": "(MIT OR CC0-1.0)",
      "engines": {
        "node": ">=12.20"
      },
      "funding": {
        "url": "https://github.com/sponsors/sindresorhus"
      }
    },
    "node_modules/type-is": {
      "version": "1.6.18",
      "resolved": "https://registry.npmjs.org/type-is/-/type-is-1.6.18.tgz",
      "integrity": "sha512-TkRKr9sUTxEH8MdfuCSP7VizJyzRNMjj2J2do2Jr3Kym598JVdEksuzPQCnlFPW4ky9Q+iA+ma9BGm06XQBy8g==",
      "license": "MIT",
      "dependencies": {
        "media-typer": "0.3.0",
        "mime-types": "~2.1.24"
      },
      "engines": {
        "node": ">= 0.6"
      }
    },
    "node_modules/undefsafe": {
      "version": "2.0.5",
      "resolved": "https://registry.npmjs.org/undefsafe/-/undefsafe-2.0.5.tgz",
      "integrity": "sha512-WxONCrssBM8TSPRqN5EmsjVrsv4A8X12J4ArBiiayv3DyyG3ZlIg6yysuuSYdZsVz3TKcTg2fd//Ujd4CHV1iA==",
      "license": "MIT"
    },
    "node_modules/unpipe": {
      "version": "1.0.0",
      "resolved": "https://registry.npmjs.org/unpipe/-/unpipe-1.0.0.tgz",
      "integrity": "sha512-pjy2bYhSsufwWlKwPc+l3cN7+wuJlK6uz0YdJEOlQDbl6jo/YlPi4mb8agUkVC8BF7V8NuzeyPNqRksA3hztKQ==",
      "license": "MIT",
      "engines": {
        "node": ">= 0.8"
      }
    },
    "node_modules/use-sync-external-store": {
      "version": "1.4.0",
      "resolved": "https://registry.npmjs.org/use-sync-external-store/-/use-sync-external-store-1.4.0.tgz",
      "integrity": "sha512-9WXSPC5fMv61vaupRkCKCxsPxBocVnwakBEkMIHHpkTTg6icbJtg6jzgtLDm4bl3cSHAca52rYWih0k4K3PfHw==",
      "license": "MIT",
      "peerDependencies": {
        "react": "^16.8.0 || ^17.0.0 || ^18.0.0 || ^19.0.0"
      }
    },
    "node_modules/utils-merge": {
      "version": "1.0.1",
      "resolved": "https://registry.npmjs.org/utils-merge/-/utils-merge-1.0.1.tgz",
      "integrity": "sha512-pMZTvIkT1d+TFGvDOqodOclx0QWkkgi6Tdoa8gC8ffGAAqz9pzPTZWAybbsHHoED/ztMtkv/VoYTYyShUn81hA==",
      "license": "MIT",
      "engines": {
        "node": ">= 0.4.0"
      }
    },
    "node_modules/validator": {
      "version": "13.12.0",
      "resolved": "https://registry.npmjs.org/validator/-/validator-13.12.0.tgz",
      "integrity": "sha512-c1Q0mCiPlgdTVVVIJIrBuxNicYE+t/7oKeI9MWLj3fh/uq2Pxh/3eeWbVZ4OcGW1TUf53At0njHw5SMdA3tmMg==",
      "license": "MIT",
      "engines": {
        "node": ">= 0.10"
      }
    },
    "node_modules/vary": {
      "version": "1.1.2",
      "resolved": "https://registry.npmjs.org/vary/-/vary-1.1.2.tgz",
      "integrity": "sha512-BNGbWLfd0eUPabhkXUVm0j8uuvREyTh5ovRa/dyow/BqAbZJyC+5fU+IzQOzmAKzYqYRAISoRhdQr3eIZ/PXqg==",
      "license": "MIT",
      "engines": {
        "node": ">= 0.8"
      }
    },
    "node_modules/webcrypto-core": {
      "version": "1.8.1",
      "resolved": "https://registry.npmjs.org/webcrypto-core/-/webcrypto-core-1.8.1.tgz",
      "integrity": "sha512-P+x1MvlNCXlKbLSOY4cYrdreqPG5hbzkmawbcXLKN/mf6DZW0SdNNkZ+sjwsqVkI4A4Ko2sPZmkZtCKY58w83A==",
      "license": "MIT",
      "dependencies": {
        "@peculiar/asn1-schema": "^2.3.13",
        "@peculiar/json-schema": "^1.1.12",
        "asn1js": "^3.0.5",
        "pvtsutils": "^1.3.5",
        "tslib": "^2.7.0"
      }
    },
    "node_modules/webcrypto-core/node_modules/tslib": {
      "version": "2.8.1",
      "resolved": "https://registry.npmjs.org/tslib/-/tslib-2.8.1.tgz",
      "integrity": "sha512-oJFu94HQb+KVduSUQL7wnpmqnfmLsOA/nAh6b6EH0wCEoK0/mPeXU6c3wKDV83MkOuHPRHtSXKKU99IBazS/2w==",
      "license": "0BSD"
    },
    "node_modules/webidl-conversions": {
      "version": "7.0.0",
      "resolved": "https://registry.npmjs.org/webidl-conversions/-/webidl-conversions-7.0.0.tgz",
      "integrity": "sha512-VwddBukDzu71offAQR975unBIGqfKZpM+8ZX6ySk8nYhVoo5CYaZyzt3YBvYtRtO+aoGlqxPg/B87NGVZ/fu6g==",
      "license": "BSD-2-Clause",
      "engines": {
        "node": ">=12"
      }
    },
    "node_modules/whatwg-url": {
      "version": "14.2.0",
      "resolved": "https://registry.npmjs.org/whatwg-url/-/whatwg-url-14.2.0.tgz",
      "integrity": "sha512-De72GdQZzNTUBBChsXueQUnPKDkg/5A5zp7pFDuQAj5UFoENpiACU0wlCvzpAGnTkj++ihpKwKyYewn/XNUbKw==",
      "license": "MIT",
      "dependencies": {
        "tr46": "^5.1.0",
        "webidl-conversions": "^7.0.0"
      },
      "engines": {
        "node": ">=18"
      }
    }
  }
}
</file>

<file path="package.json">
{
  "name": "music-therapy",
  "version": "1.0.0",
  "main": "server.js",
  "type": "module",
  "scripts": {
    "start": "node server.js",
    "dev": "nodemon server.js"
  },
  "keywords": [],
  "author": "",
  "license": "ISC",
  "description": "",
  "dependencies": {
    "@clerk/clerk-sdk-node": "^4.13.23",
    "@fortawesome/fontawesome-free": "^6.7.2",
    "@google-cloud/language": "^7.0.1",
    "@google-cloud/storage": "^7.15.2",
    "@google/generative-ai": "^0.24.0",
    "@huggingface/inference": "^3.6.2",
    "axios": "^1.8.4",
    "bcryptjs": "^3.0.2",
    "connect-mongo": "^5.1.0",
    "cookie-parser": "^1.4.7",
    "cors": "^2.8.5",
    "crypto": "^1.0.1",
    "dotenv": "^16.4.7",
    "express": "^4.21.2",
    "express-async-errors": "^3.1.1",
    "express-session": "^1.18.1",
    "express-validator": "^7.2.1",
    "jsonwebtoken": "^9.0.2",
    "mongoose": "^8.13.0",
    "nodemon": "^3.1.9",
    "openai": "^4.89.1",
    "qrcode": "^1.5.4",
    "socket.io": "^4.8.1",
    "spotify-web-api-node": "^5.0.2",
    "ws": "^8.18.1"
  }
}
</file>

<file path="server.js">
import cors from "cors";
import dotenv from "dotenv";
import express from "express";
import "express-async-errors";
import session from 'express-session';
import http from 'http';
import { Server } from 'socket.io';
import connectDB from "./config/database.js";
import errorHandler from "./middlewares/errorHandler.js";
import { initializeDefaultBadges } from "./services/badgeService.js";
// Import routes
import authRoutes from './routes/authRoutes.js';
import gamificationRoutes from './routes/gamificationRoutes.js';
import geminiRoutes from './routes/geminiRoutes.js';
import leaderboardRoutes from './routes/leaderboardRoutes.js';
import musicRoutes from './routes/musicRoutes.js';
import playlistRoutes from './routes/playlistRoutes.js';
import userRoutes from './routes/userRoutes.js';
import SocketManager from "./services/socketManager.js";

dotenv.config();
const app = express();

// Connect to MongoDB
connectDB();

const server=http.createServer(app);

//session options
const sessionOptions={
  secret:'mysupersecretcode',
  resave:false,
  saveUninitialized:false
}
//Initializing badges database
initializeDefaultBadges();

app.use(session(sessionOptions));
// Middleware
app.use(cors({
  origin: 'http://localhost:5173', // Allow  Vite frontend
  credentials: true // Important for cookies
}));
app.use(express.json());

//Initializing Socket.io with cors configuration
const io=new Server(server,{
  cors:{
    origin:'http://localhost:5173',
    methods:['GET','POST','PUT', 'DELETE'],
    credentials:true
  }
});
const socketManager= new SocketManager(io);
// Routes
app.get("/", (req, res) => {
  res.send("Server is running...");
});
app.use((req,res,next)=>{
  req.socketManager=socketManager;
  req.io=io;
  next();
});
app.use('/api/auth', authRoutes);
app.use('/api/music/recommend', musicRoutes);
app.use('/api/users', userRoutes);
app.use('/api/gemini', geminiRoutes);
app.use('/api/playlists', playlistRoutes);
app.use('/api/gamification',gamificationRoutes);
app.use('/api/leaderboard',leaderboardRoutes);
// Global Error Handler
app.use(errorHandler);
const PORT = process.env.PORT || 3000;
// app.listen(PORT, () => console.log(`Server running on PORT ${PORT}`));
server.listen(PORT,()=> console.log(`Server running on port ${PORT}`));
</file>

</files>
